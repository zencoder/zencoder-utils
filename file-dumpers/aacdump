#!/usr/bin/env ruby

#
# AAC Dump (for ADTS format .aac files)
# Can support leading ID3 tags, too.
#

def error(msg); puts msg; exit; end

class IO
  def ui8; read(1).unpack('C').first; end
  def ui16; read(2).unpack('n').first; end
  def ui32; read(4).unpack('N').first; end
  def ui24; ("\000" + read(3)).unpack('N').first; end
  def si24; v = ui24; v >= (2**23) ? v-(2**24) : v; end

  def id3_size;
    bytes = read(4).unpack('C*')
    (bytes[3] & 0x7f) + ((bytes[2] & 0x7f) << 7) + ((bytes[1] & 0x7f) << 14) + ((bytes[0] & 0x7f) << 21)
  end
end

class Bitstream
  attr_accessor :bit_offset, :total_bits
  
  def initialize(data_string, starting_byte_offset = 0)
    @data = data_string
    @total_bits = @data.length * 8
    @bit_offset = 0
    @pos = starting_byte_offset
  end

  def nextbits(count)
    raise "nextbits of more than 16 not implemented" if count > 16
    getbits_internal(count, false)
  end

  # Return an integer of the next _count_ bits and increment @bit_offset so that
  # subsequent calls will get following bits.
  def getbits(count)
    value = 0
    while count > 16
      value += (getbits_internal(16) << 16)
      count -= 16
    end
    value += getbits_internal(count)
  end
  
  # Do getbits, with up to 16 bits.
  def getbits_internal(count, increment_position = true)
    return 0 if count > 16 || count < 1
    byte = @bit_offset / 8
    bit  = @bit_offset % 8
    val = (@data[@pos + byte].to_i << 16) + (@data[@pos + byte + 1].to_i << 8) + @data[@pos + byte + 2].to_i
    val = (val << bit) & 16777215
    val = val >> (24 - count)

    @bit_offset += count if increment_position
    return val
  end
  
  def append(data_string)
    @data << data_string
    @total_bits += data_string.length
  end
  
  # Remove any data that we've moved past already, so we don't build up too much in memory.
  def pop
    byte = @bit_offset / 8
    bit = @bit_offset % 8

    @pos += byte
    @bit_offset = bit

    if @pos > 0
      @data = @data[@pos..-1]
      @pos = 0
    end

    @total_bits = @data.length * 8

    true
  end
end

def parse_id3_tags(input_file)
  puts "Parsing ID3 tags..."
  major_version,minor_version,flags = input_file.read(3).unpack('C*')
  error "ID3 versions other than 2.4 are not yet supported!" unless major_version == 4
  
  total_id3_size = input_file.id3_size
  puts "id3 header size: #{total_id3_size}"

  data_bytes_read = 0
  while data_bytes_read < total_id3_size
    tag = input_file.read(4)
    size = input_file.id3_size
    flags = input_file.read(2)
    data = input_file.read(size)
    data_bytes_read += 10 + size
    puts "ID3 tag: #{tag} of size #{size}"
    
    case tag
    when 'PRIV':
      if data =~ /^com\.apple\.streaming\.transportStreamTimestamp\x00/
        timestamp = $'.unpack('NN').inject(0) { |s,v| (s << 32) + v }
        puts "  Apple Timestamp: #{timestamp} (%0.3f seconds)" % (timestamp.to_f / 90000)
      end
    end
  end
end

mpeg2_profiles = {
  0 => "Main",
  1 => "Low Complexity",
  2 => "Scalable Sample Rate",
  3 => "<reserved>",
}

mpeg4_profiles = {
  0 => "Main",
  1 => "AAC-LC",
  2 => "AAC Scalable Sample Rate",
  3 => "AAC LTP",
}

aac_sample_rates = {
  0 => 96000,
  1 => 88200,
  2 => 64000,
  3 => 48000,
  4 => 44100,
  5 => 32000,
  6 => 24000,
  7 => 22050,
  8 => 16000,
  9 => 12000,
  10 => 11025,
  11 => 8000,
  12 => 7350,
  13 => "<reserved>",
  14 => "<reserved>",
  15 => "<forbidden>"
}

aac_channel_configs = {
  0 => "<sent out of band>",
  1 => "1 channel: front-center",
  2 => "2 channels: front-left, front-right",
  3 => "3 channels: front-center, front-left, front-right",
  4 => "4 channels: front-center, front-left, front-right, back-center",
  5 => "5 channels: front-center, front-left, front-right, back-left, back-right",
  6 => "6 channels: front-center, front-left, front-right, back-left, back-right, LFE-channel",
  7 => "8 channels: front-center, front-left, front-right, side-left, side-right, back-left, back-right, LFE-channel",
}

ONLY_LONG_SEQUENCE = 0
LONG_START_SEQUENCE = 1
EIGHT_SHORT_SEQUENCE = 2
LONG_STOP_SEQUENCE = 3

ID_SCE = 0
ID_CPE = 1
ID_CCE = 2
ID_LFE = 3
ID_DSE = 4
ID_PCE = 5
ID_FIL = 6
ID_END = 7

EXT_FILL = 0
EXT_FILL_DATA = 1
EXT_DYNAMIC_RANGE = 0b1011
EXT_SBR_DATA = 0b1101
EXT_SBR_DATA_CRC = 0b1110


PRED_SFB_MAX = {
  96000 => 33,
  88200 => 33,
  64000 => 38,
  48000 => 40,
  44100 => 40,
  32000 => 40,
  24000 => 41,
  22050 => 41,
  16000 => 37,
  12000 => 37,
  11025 => 37,
   8000 => 34
}

def individual_channel_stream(bitstream, common_window)
  global_gain = bitstream.getbits(8)
  if common_window == 0
    ics_info(bitstream)
  end

  section_data

  scale_factor_data

  pulse_data_present = bitstream.getbits(1)
  if pulse_data_present
    pulse_data
  end

  tns_data_present = bitstream.getbits(1)
  if tns_data_present
    tns_data
  end

  gain_control_data_present = bitstream.getbits(1)
  if gain_control_data_present
    gain_control_data
  end

  spectral_data
end

def ics_info(bitstream)
  ics_reserved_bit = bitstream.getbits(1)
  window_sequence = bitstream.getbits(2)
  window_shape = bitstream.getbits(1)
  if window_sequence == EIGHT_SHORT_SEQUENCE
    max_sfb = bitstream.getbits(4)
    scale_factor_grouping = bitstream.getbits(7)
  else
    max_sfb = bitstream.getbits(6)
    predictor_data_present = bitstream.getbits(1)
    if predictor_data_present == 1
      predictor_reset = bitstream.getbits(1)
      if predictor_reset == 1
        predictor_reset_group_number = bitstream.getbits(5)
      end
      prediction_used = []
      [max_sfb, PRED_SFB_MAX[@sample_rate]].min.times do
        prediction_used << bitstream.getbits(1)
      end
    end
  end
end

def extension_payload(bitstream, count)
  extension_type = bitstream.getbits(4)
  case extension_type
  when EXT_DYNAMIC_RANGE:
    # dynamic_range_info(bitstream)
  when EXT_SBR_DATA:
    puts "  SBR DATA!"
    # sbr_extension_data(bitstream, id_aac, 0)
  when EXT_SBR_DATA_CRC:
    # sbr_extension_data(bitstream, id_aac, 1)
    puts "  SBR DATA!"
  when EXT_FILL_DATA:
    # fill_nibble = bitstream.getbits(4)
    # (count - 1).times { bitstream.getbits(8) }
    # return count
  else
    # Treat just like EXT_FILL_DATA but if we were
    # validating, we wouldn't care what the data was.
    # fill_nibble = bitstream.getbits(4)
    # (count - 1).times { bitstream.getbits(8) }
    # return count
  end
  fill_nibble = bitstream.getbits(4)
  (count - 1).times { bitstream.getbits(8) }
  return count
end

def read_syntax_element(bitstream)
  se_id = bitstream.getbits(3)
  puts "  Syntax element: #{se_id}"
  case se_id
  when ID_SCE:
    instance_tag = bitstream.getbits(4)
    individual_channel_stream(bitstream, 0)
    {}
  when ID_CPE:
    instance_tag = bitstream.getbits(4)
    common_window = bitstream.getbits(1)
    if common_window == 1
      ics_info(bitstream)
      ms_mask_present = bitstream.getbits(2)
      if ms_mask_present == 1
        raise "ms_mask stuff not yet supported"
      end
    end
    individual_channel_stream(bitstream, common_window)
    {}
  when ID_CCE:
    {}
  when ID_LFE:
    {}
  when ID_DSE:
    {}
  when ID_PCE:
    {}
  when ID_FIL:
    count = bitstream.getbits(4)
    if count == 15
      count += bitstream.getbits(8)
    end
    while count > 0
      count -= extension_payload(bitstream, count)
    end
    { :id => ID_FIL }
  when ID_END:
    { :id => ID_END }
  else
    puts "  UNKNOWN SYNTAX ELEMENT"
    { :id => -1 }
  end
end

error "Please specify a file to inspect." unless ARGV.length > 0

input_filename = ARGV.first
error "Input file not found." unless File.exist?(input_filename)

file_size = File.size(input_filename)
input_file = File.open(input_filename)

puts
puts "INFO:"
puts "Filename: " + File.basename(input_filename)
puts "Size: #{file_size}"

signature = input_file.read(3)
if signature == 'ID3'
  parse_id3_tags(input_file)
  signature = input_file.read(3)
end

error "Not an ADTS AAC file" unless signature.unpack('H*').first =~ /^fff/


while !input_file.eof?
  if signature
    adts_header_data = signature + input_file.read(6)
    signature = nil
  else
    adts_header_data = input_file.read(9)
  end
  header = Bitstream.new(adts_header_data)

  syncword =                       header.getbits(12)
  id =                             header.getbits(1)
  layer =                          header.getbits(2)
  protection_absent =              header.getbits(1)
  profile =                        header.getbits(2)
  sampling_frequency_index =       header.getbits(4)
  private_bit =                    header.getbits(1)
  channel_configuration =          header.getbits(3)
  is_copy =                        header.getbits(1)
  home =                           header.getbits(1)
  copyright_identification_bit =   header.getbits(1)
  copyright_identification_start = header.getbits(1)
  aac_frame_length =               header.getbits(13)
  adts_buffer_fullness =           header.getbits(11)
  num_raw_data_blocks_in_frame =   header.getbits(2)
  crc_check =                      header.getbits(16)

  puts "ADTS Header: (offset #{input_file.pos - 9})"
  puts "  Error: Invalid syncword!" unless syncword == 0xfff
  if id == 0
    puts "  MPEG-4"
    puts "  Profile: #{mpeg4_profiles[profile]}"
  else
    puts "  MPEG-2"
    puts "  Profile: #{mpeg2_profiles[profile]}"
  end
  # puts "  Sampling Frequency Index: #{sampling_frequency_index}"
  @sample_rate = aac_sample_rates[sampling_frequency_index]
  puts "  Sample Rate: #{@sample_rate}"
  # puts "  Channel Configuration: #{channel_configuration}"
  puts "  Channels: #{aac_channel_configs[channel_configuration]}"
  puts "  AAC Frame Length: #{aac_frame_length}"
  puts "  ADTS Buffer Fullness: #{adts_buffer_fullness}"
  puts "  Num blocks in frame: #{num_raw_data_blocks_in_frame}(+1)"
  
  data_length = aac_frame_length - 9 # 9 bytes for the header
  aac_data = input_file.read(data_length) if data_length > 0
  
  if aac_data.length == data_length
    data = Bitstream.new(aac_data)

    if num_raw_data_blocks_in_frame == 0
      # adts_error_check
      if protection_absent == 0
        crc = data.getbits(16)
      end

      # raw_data_block
      while data.bit_offset < data.total_bits
        syntax_element = read_syntax_element(data)
        break if syntax_element[:id] == ID_END

        # break # We don't parse 'em right yet, so quit out.
      end
    else
      # adts_header_error_check
      if protection_absent == 0
        positions = []
        num_raw_data_blocks_in_frame.times { positions << data.getbits(16) }
        crc = data.getbits(16)
      end

      (num_raw_data_blocks_in_frame + 1).times do
        # raw_data_block
        while data.bit_offset < data.total_bits
          syntax_element = read_syntax_element(data)
          break if syntax_element[:id] == ID_END

          # break # We don't parse 'em right yet, so quit out.
        end

        # adts_raw_data_block_error_check
        if protection_absent == 0
          crc = data.getbits(16)
        end
      end
    end

  else
    puts "  Data shorter than expected -- not decoding!"
  end
end

puts
input_file.close rescue nil
