#!/usr/bin/env ruby

#
# MP4 Dump
#

$:.unshift(File.dirname(__FILE__))
require 'dump_helpers'
require 'zlib'
require 'base64'


class BoxFile
  attr_accessor :boxes

  def initialize(data_stream, base_offset = 0)
    @data = data_stream
    @boxes = []
  end

  def parse
    while (box = Box.read(@data))
      boxes << box
      break if box.size == 0 # Zero size means it extends to the end of the file.
      break if !box.valid
    end
    self
  end

  def print_tree
    puts
    @boxes.each { |box| box.print_tree }
    if @boxes.length == 0
      puts "Empty Tree!"
    end
    puts
  end
end

class Box
  attr_accessor :base_offset, :kind, :size, :data_size
  attr_accessor :data_offset, :data, :data_stream, :parent, :children, :valid

  # Register each box kind with what handles it.
  HANDLERS = {}
  DESCRIPTIONS = {}
  def self.handles(kind, description = nil)
    Box::HANDLERS[kind] = self
    Box::DESCRIPTIONS[kind] = description
  end

  def self.read(stream, options = {})
    size,kind = stream.ui32,stream.fourcc rescue nil

    # Sometimes metatdata gets confusing, so skip leading zero chunks.
    while size == 0
      size = kind.unpack('N').first
      kind = stream.fourcc
    end
    return nil if size.nil?

    handler = Box::HANDLERS[kind] || Box
    handler.new(stream, kind, size, options)
  end

  def initialize(stream, kind, size, options = {})
    # Handle extended header sizes
    if size == 1
      size = stream.ui64
      header_size = 16
    else
      header_size = 8
    end
    @data_offset = stream.pos
    @base_offset = @data_offset - header_size
    # puts "DEBUG: Found #{kind} box at #{@base_offset} with size of #{size}"
    @kind = kind
    @size = size
    @data_size = size - header_size
    @data = nil
    @children = []
    @parent = options[:parent]
    read_data(stream)

    # Make sure to read in any trailing junk data.
    if stream.pos < @base_offset + @size
      stream.seek(@base_offset + @size)
    end

    @valid = true
  rescue => e
    STDERR.puts e.inspect
    STDERR.puts "  " + e.backtrace.join("\n  ")
  end

  def read_data(stream)
    # stream.seek(@data_size, IO::SEEK_CUR)
  end

  def description
    Box::DESCRIPTIONS[@kind]
  end

  def print_tree(prefix = '')
    color = :cyan
    if @children.length > 0
      color = :yellow
    elsif @parent.nil?
      color = :green
    end
    print prefix
    cprint @kind, color
    cprint(" - " + description, color) if description
    puts " at #{@base_offset} (#{@size} bytes)"
    print_extra_info(prefix + '|   ')
    @children.each { |box| box.print_tree(prefix + '|   ') }
  end

  def print_extra_info(prefix = '')
  end

  def find_parent(parent_kind)
    return self if @kind == parent_kind
    return nil if @parent.nil?
    return @parent.find_parent(parent_kind)
  end

  def first_child(child_kind)
    @children.detect { |c| c.kind == child_kind }
  end

  def print_sample_flags(flags, prefix = '')
    value_names = ['Unknown','Yes',' No','Invalid/Reserved']

    sample_depends_on = (flags >> 24) & 3
    sample_is_depended_on = (flags >> 22) & 3
    sample_has_redundancy = (flags >> 20) & 3
    sample_padding_value = (flags >> 17) & 7
    sample_is_difference_sample = (flags >> 16) & 1
    sample_degradation_priority = flags & 0xffff

    print prefix
    cputs "Depends on others: #{value_names[sample_depends_on]}", :dark_gray
    print prefix
    cputs "Depdended on by others: #{value_names[sample_is_depended_on]}", :dark_gray
    print prefix
    cputs "Has redundancy: #{value_names[sample_has_redundancy]}", :dark_gray
    print prefix
    cputs "Padding value: #{sample_padding_value}", :dark_gray
    print prefix
    cputs "Is difference sample (not key/sync): #{sample_is_difference_sample == 1 ? 'Yes' : 'No'}", :dark_gray
    print prefix
    cputs "Degradation Priority: #{sample_degradation_priority}", :dark_gray
  end
end

class BoxWithChildren < Box
  handles 'moov', 'Movie'
  handles 'cmov', 'Compressed Movie'
  handles 'trak', 'Track'
  handles 'mdia', 'Media'
  handles 'minf', 'Media Information'
  handles 'dinf', 'Data Information'
  handles 'stbl', 'Sample Table'
  handles 'tapt', 'Track Aperture Mode Dimensions'
  handles 'edts', 'Edits'

  handles 'mvex', 'Movie Extends'
  handles 'moof', 'Movie Fragment'
  handles 'traf', 'Track Fragment'
  handles 'mfra', 'Movie Fragment Random Access'
  handles 'udta', 'User Data'
  handles 'encv', 'Encrypted Video'

  def read_data(stream)
    while stream.pos < (@base_offset + @size - 7) && (box = Box.read(stream, :parent => self))
      @children << box
    end

    remainder = (@base_offset + @size) - stream.pos
    stream.read(remainder) if remainder > 0
  end
end

class CmvdBox < Box
  handles 'cmvd', 'Compressed Movie Data'

  attr_accessor :uncompressed_size

  def read_data(stream)
    @uncompressed_size = stream.ui32
    uncompressed_data = Zlib::Inflate.inflate(stream.read(@data_size - 4)) #rescue nil
    if uncompressed_data
      child_file = BoxFile.new(StringIO.new(uncompressed_data)).parse
      @children = child_file.boxes
    end
  end

end

class FtypBox < Box
  handles 'ftyp', 'File Type'

  attr_accessor :major_brand, :minor_version, :compatible_brands

  def initialize(*args)
    @compatible_brands = []
    super
  end

  def read_data(stream)
    @major_brand = stream.fourcc
    @minor_version = stream.ui32
    ((@data_size - 8) / 4).times do
      @compatible_brands << stream.fourcc
    end
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Brand: #{@major_brand}, Version: #{@minor_version}", :dark_gray
    @compatible_brands.each do |cb|
      print prefix
      cputs "Compatible Brand: #{cb}", :dark_gray
    end
  end
end

class MvhdBox < Box
  handles 'mvhd', 'Movie Header'

  attr_accessor :timescale, :duration, :play_rate, :play_volume

  def read_data(stream)
    version = stream.ui8
    @flags = stream.ui24
    if version == 1
      ctime = stream.ui64 # Seconds since Jan 1, 1904
      mtime = stream.ui64 # Seconds since Jan 1, 1904
      @timescale = stream.ui32 # Yeah, still 32.
      @duration = stream.ui64
    else
      ctime = stream.ui32 # Seconds since Jan 1, 1904
      mtime = stream.ui32 # Seconds since Jan 1, 1904
      @timescale = stream.ui32
      @duration = stream.ui32
    end
    @play_rate = stream.fixed32
    @play_volume = stream.fixed16
    stream.read(10) # Reserved
    matrix = stream.read(36)
    preview_start = stream.ui32
    preview_duration = stream.ui32
    poster_time = stream.ui32
    selection_start = stream.ui32
    selection_duration = stream.ui32
    playhead = stream.ui32
    next_track_id = stream.ui32
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Timescale: #{@timescale}", :dark_gray
    print prefix
    if @timescale > 0
      cputs "Duration: #{@duration} (#{sprintf('%0.3f',@duration.to_f / @timescale)} seconds)", :dark_gray
    else
      cputs "Duration: #{@duration}", :dark_gray
    end
    print prefix
    cputs "Play Rate: #{@play_rate}", :dark_gray
    print prefix
    cputs "Play Volume: #{@play_volume}", :dark_gray
  end
end

class MfhdBox < Box
  handles 'mfhd', 'Movie Fragment Header'

  attr_accessor :sequence_number

  def read_data(stream)
    version = stream.ui8
    flags = stream.ui24
    @sequence_number = stream.ui32
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Sequence Number: #{@sequence_number}", :dark_gray
  end
end

class TkhdBox < Box
  handles 'tkhd', 'Track Header'

  attr_accessor :flags, :track_id, :duration, :layer, :volume, :width, :height

  MATRIX_DECODER = {
    # [A, B, C, D] of QT matrix.  If it doesn't match one
    # of these patterns, it's probably a weird rotation angle or something.
    [ 1,  0,  0,  1] => { :rotate =>   0, :flip => :none },
    [ 1,  0,  0, -1] => { :rotate =>   0, :flip => :vertical },
    [ 0,  1, -1,  0] => { :rotate =>  90, :flip => :none },
    [ 0,  1,  1,  0] => { :rotate =>  90, :flip => :horizontal },
    [-1,  0,  0, -1] => { :rotate => 180, :flip => :none },
    [-1,  0,  0,  1] => { :rotate => 180, :flip => :vertical }, # Equivalent to just a horizontal flip.
    [ 0, -1,  1,  0] => { :rotate => 270, :flip => :none },
    [ 0, -1, -1,  0] => { :rotate => 270, :flip => :horizontal }
  }

  def read_data(stream)
    version = stream.ui8
    @flags = stream.ui24
    if version == 1
      ctime = stream.ui64 # Seconds since Jan 1, 1904
      mtime = stream.ui64 # Seconds since Jan 1, 1904
      @track_id = stream.ui32
      reserved = stream.read(4)
      @duration = stream.ui64
    else
      ctime = stream.ui32 # Seconds since Jan 1, 1904
      mtime = stream.ui32 # Seconds since Jan 1, 1904
      @track_id = stream.ui32
      reserved = stream.read(4)
      @duration = stream.ui32
    end
    reserved = stream.read(8)
    @layer = stream.si16
    alt_group = stream.ui16
    @volume = stream.fixed16
    reserved = stream.read(2)
    @matrix = stream.read(36)
    @width = stream.fixed32
    @height = stream.fixed32

    # MATRIX DECODING
    # -> 4 bytes decimal window geometry matrix value A
    #    = long fixed point width scale (normal = 1.0)
    # -> 4 bytes decimal window geometry matrix value B
    #    = long fixed point width rotate (normal = 0.0)
    # -> 4 bytes decimal window geometry matrix value U
    #    = long fixed point width angle (restricted to 0.0)
    # -> 4 bytes decimal window geometry matrix value C
    #    = long fixed point height rotate (normal = 0.0)
    # -> 4 bytes decimal window geometry matrix value D
    #    = long fixed point height scale (normal = 1.0)
    # -> 4 bytes decimal window geometry matrix value V
    #    = long fixed point height angle (restricted to 0.0)
    # -> 4 bytes decimal window geometry matrix value X
    #    = long fixed point positon (left = 0.0)
    # -> 4 bytes decimal window geometry matrix value Y
    #    = long fixed point positon (top = 0.0)
    # -> 4 bytes decimal window geometry matrix value W
    #    = long fixed point divider scale (restricted to 1.0)

    # Matrix rotation = atan2(b, a)*180/3.14159
    # Vertical flip before rotate unless (atan2(d, c)*180/3.14159 - 90) is equal to rotation.  (beware float math)

    # Decode the 4 matrix positions we care about.
    @matrix_ABCD = []
    [0,4,12,16].each do |byte_position|
      @matrix_ABCD << @matrix[byte_position,4].unpack('cCCC').inject(0) { |s,v| (s<<8) + v }.to_f / 2**16
    end

    # Simplify to just -1, 0, and 1 representing negative/positive/zero values.
    @matrix_simplified = @matrix_ABCD.map { |v| (v > 0.01) ? 1 : ((v < -0.01) ? -1 : 0) }

    # If any values are not zero or 1, then it stretches stuff.
    @matrix_stretches = @matrix_ABCD.any? { |v| ![-1.0, 0.0, 1.0].include?(v) }
    
    decoded = MATRIX_DECODER[@matrix_simplified]
    if decoded
      @rotation = decoded[:rotate]
      @flip = decoded[:flip]
    else
      @rotation = 'Unknown'
      @flip = 'Unknown'
    end
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Track ID: #{@track_id}", :dark_gray
    print prefix
    cputs "Duration: #{@duration}", :dark_gray
    print prefix
    cputs "Width: #{@width}", :dark_gray
    print prefix
    cputs "Height: #{@height}", :dark_gray
    if @rotation != 0
      print prefix
      cputs "Rotate: #{@rotation}", :dark_gray
    end
    if @flip != :none
      print prefix
      cputs "Flip: #{@flip}", :dark_gray
    end
    if @matrix_stretches
      print prefix
      cputs "Matrix stretches non-uniformly!", :yellow
    end
    
    if $VERBOSE
      print prefix
      cputs "Matrix: [#{@matrix_ABCD[0]}, #{@matrix_ABCD[1]}, x]", :dark_gray
      print prefix
      cputs "        [#{@matrix_ABCD[2]}, #{@matrix_ABCD[3]}, x]", :dark_gray
      print prefix
      cputs "        [  x,   x, x]", :dark_gray
      print prefix
      cputs "Enabled: #{(@flags & 1) > 0 ? 'Yes' : 'No'}", :dark_gray
      print prefix
      cputs "In Movie: #{(@flags & 2) > 0 ? 'Yes' : 'No'}", :dark_gray
      print prefix
      cputs "In Preview: #{(@flags & 4) > 0 ? 'Yes' : 'No'}", :dark_gray
      print prefix
      cputs "In Poster: #{(@flags & 8) > 0 ? 'Yes' : 'No'}", :dark_gray
      print prefix
      cputs "Layer: #{@layer}", :dark_gray
      print prefix
      cputs "Volume: #{@volume}", :dark_gray
    end
  end
end

class MehdBox < Box
  handles 'mehd', 'Movie Extends Header'

  attr_accessor :version, :flags, :fragment_duration
  def read_data(stream)
    @version, @flags = stream.ui8, stream.ui24

    if @version == 1
      @fragment_duration = stream.si64
    else
      @fragment_duration = stream.si32
    end
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Fragment Duration: #{@fragment_duration}", :dark_gray
  end
end

class TrexBox < Box
  handles 'trex', 'Track Extends'

  attr_accessor :version, :flags, :track_id
  attr_accessor :default_sample_description_index, :default_sample_duration, :default_sample_size, :default_sample_flags
  def read_data(stream)
    @version, @flags = stream.ui8, stream.ui24

    @track_id = stream.ui32
    @default_sample_description_index = stream.ui32
    @default_sample_duration = stream.ui32
    @default_sample_size = stream.ui32
    @default_sample_flags = stream.ui32
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Track ID: #{@track_id}", :dark_gray
    print prefix
    cputs "Default Sample Description Index: #{@default_sample_description_index}", :dark_gray
    print prefix
    cputs "Default Sample Duration: #{@default_sample_duration}", :dark_gray
    print prefix
    cputs "Default Sample Size: #{@default_sample_size}", :dark_gray
    print prefix
    cputs "Default Sample Flags: #{@default_sample_flags}", :dark_gray
    print_sample_flags(@default_sample_flags, prefix + '  ') if $VERBOSE
  end
end

class TfhdBox < Box
  handles 'tfhd', 'Track Fragment Header'

  attr_accessor :flags, :track_id, :duration, :layer, :volume, :width, :height

  def read_data(stream)
    version = stream.ui8
    @flags = stream.ui24
    @base_data_offset_present = @flags & 0x01
    @sample_desc_index_present = @flags & 0x02
    @default_sample_duration_present = @flags & 0x08
    @default_sample_size_present = @flags & 0x10
    @default_sample_flags_present = @flags & 0x20
    @duration_is_empty = @flags & 0x010000

    @track_id = stream.ui32
    @base_data_offset = stream.ui64 if @base_data_offset_present > 0
    @sample_desc_index = stream.ui32 if @sample_desc_index_present > 0
    @default_sample_duration = stream.ui32 if @default_sample_duration_present > 0
    @default_sample_size = stream.ui32 if @default_sample_size_present > 0
    @default_sample_flags = stream.ui32 if @default_sample_flags_present > 0
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Track ID: #{@track_id}", :dark_gray
    if @base_data_offset_present > 0
      print prefix
      cputs "Base Data Offset: #{@base_data_offset}", :dark_gray
    end
    if @sample_desc_index_present > 0
      print prefix
      cputs "Sample Description Index: #{@sample_desc_index}", :dark_gray
    end
    if @default_sample_duration_present > 0
      print prefix
      cputs "Default Sample Duration: #{@default_sample_duration}", :dark_gray
    end
    if @default_sample_size_present > 0
      print prefix
      cputs "Default Sample Size: #{@default_sample_size}", :dark_gray
    end
    if @default_sample_flags_present > 0
      print prefix
      cputs "Default Sample Flags: #{@default_sample_flags}", :dark_gray
      print_sample_flags(@default_sample_flags, prefix + '  ') if $VERBOSE
    end
    print prefix
    cputs "Duration is Empty?: #{@duration_is_empty > 0 ? 'Yes' : 'No'}", :dark_gray
  end
end

class TfdtBox < Box
  handles 'tfdt', 'Track Fragment Base Media Decode Time'

  attr_accessor :version, :flags, :base_media_decode_time
  def read_data(stream)
    @version, @flags = stream.ui8, stream.ui24

    if @version == 1
      @base_media_decode_time = stream.si64
    else
      @base_media_decode_time = stream.si32
    end
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Base Media Decode Time: #{@base_media_decode_time}", :dark_gray
  end
end

class TrunBox < Box
  handles 'trun', 'Track Fragment Run Box'

  attr_accessor :flags, :data_offset, :first_sample_flags, :entry_count, :entries

  def read_data(stream)
    version = stream.ui8
    @flags = stream.ui24

    @data_offset_present = @flags & 0x01
    @first_sample_flags_present = @flags & 0x04
    @sample_duration_present = @flags & 0x0100
    @sample_size_present = @flags & 0x0200
    @sample_flags_present = @flags & 0x0400
    @sample_composition_time_offsets_present = @flags & 0x0800
    @duration_is_empty = @flags & 0x010000

    @entry_count = stream.ui32
    @data_offset = stream.si32 if @data_offset_present > 0
    @first_sample_flags = stream.ui32 if @first_sample_flags_present > 0

    @entries = []
    @entry_count.times do
      entry = {}
      entry[:duration] = stream.ui32 if @sample_duration_present > 0
      entry[:size] = stream.ui32 if @sample_size_present > 0
      entry[:flags] = stream.ui32 if @sample_flags_present > 0
      entry[:composition_time_offset] = stream.si32 if @sample_composition_time_offsets_present > 0
      @entries << entry
    end
  end

  def print_extra_info(prefix = '')
    if @data_offset_present > 0
      print prefix
      cputs "Data Offset: #{@data_offset}", :dark_gray
    end
    print prefix
    cputs "Sample Count: #{@entry_count}", :dark_gray

    if $VERBOSE
      @entries.each do |entry|
        print prefix
        cputs "Entry Info: #{entry.inspect}", :dark_gray
      end
    end
  end
end

class MdhdBox < Box
  handles 'mdhd', 'Media Header'

  attr_accessor :version, :flags, :creation_time, :modification_time, :timescale, :duration, :language

  def initialize(*args)
    @version = nil
    @flags = nil
    super
  end

  def read_data(stream)
    @version,@flags = stream.ui8, stream.ui24
    if @version == 1
      @creation_time = stream.ui64
      @modification_time = stream.ui64
      @timescale = stream.ui32
      @duration = stream.ui64
    else
      @creation_time = stream.ui32
      @modification_time = stream.ui32
      @timescale = stream.ui32
      @duration = stream.ui32
    end

    # Language is coded with 5 bits per char: [0 11111 11111 11111], and each char is an offset from 0x60
    language_bits = stream.ui16
    @language = [10,5,0].map { |s| ((language_bits >> s) & 0x1f) + 0x60 }.pack('c3')
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Timescale: #{@timescale}", :dark_gray
    print prefix
    if @timescale > 0
      cputs "Duration: #{@duration} (#{sprintf('%0.3f',@duration.to_f / @timescale)} seconds)", :dark_gray
    else
      cputs "Duration: #{@duration}", :dark_gray
    end
    if @language != 'und'
      print prefix
      cputs "Language: #{@language}", :dark_gray
    end
  end
end

class HdlrBox < Box
  handles 'hdlr', 'Handler Description'

  attr_accessor :version, :flags, :handler_type, :handler_manufacturer, :name, :handler_qt_type

  def initialize(*args)
    @version = nil
    @flags = nil
    super
  end

  def read_data(stream)
    @version,@flags = stream.ui8, stream.ui24
    @handler_qt_type = stream.fourcc
    @handler_type = stream.fourcc
    @handler_manufacturer = stream.fourcc
    reserved2_2 = stream.ui32
    reserved2_3 = stream.ui32
    if @data_size > 24
      @name = stream.read(@data_size - 24)
      @name.sub(/\x00.*\Z/, '') # Remove null terminator and anything following.
    end
  end

  def print_extra_info(prefix = '')
    if @handler_qt_type[0,1].unpack('C').first > 0
      print prefix
      cputs "Handler QuickTime Type: #{@handler_qt_type}", :dark_gray
    end
    print prefix
    cputs "Handler Type: #{@handler_type}", :dark_gray
    if @handler_manufacturer[0,1].unpack('C').first > 0
      print prefix
      cputs "Handler Manufacturer: #{@handler_manufacturer}", :dark_gray
    end
    if @name
      print prefix
      cputs "Name: #{@name}", :dark_gray
    end
  end
end

class TaptChildBox < Box
  handles 'clef', 'Track Clean Aperture Dimensions'
  handles 'prof', 'Track Production Aperture Dimensions'
  handles 'enof', 'Track Encoded Pixels Dimensions'

  def read_data(stream)
    stream.read(4) # Version and flags -- format unknown
    @width, @height = stream.fixed32, stream.fixed32
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Width: #{@width}", :dark_gray
    print prefix
    cputs "Height: #{@height}", :dark_gray
  end
end

class SubBox < Box
  # Register each box kind with what handles it.
  HANDLERS = {}
  DESCRIPTIONS = {}
  def self.handles(kind, description = nil)
    SubBox::HANDLERS[kind] = self
    SubBox::DESCRIPTIONS[kind] = description
  end

  def self.read(stream, options = {})
    size,kind = stream.ui32,stream.fourcc rescue nil
    return nil if size.nil? || size < 1
    handler = SubBox::HANDLERS[kind] || SubBox
    handler.new(stream, kind, size, options)
  end

  def read_data(stream)
    @data = stream.read(@data_size)
    @data_stream = StringIO.new(@data)
    read_header_data(@data_stream) if @data
  end

  def read_header_data(stream)
  end

  def description
    SubBox::DESCRIPTIONS[@kind]
  end

  def print_tree(prefix = '')
    color = :dark_cyan
    if @children.length > 0
      color = :dark_yellow
    elsif @parent.nil?
      color = :dark_green
    end
    print prefix + '('
    cprint @kind, color
    cprint(" - " + description, color) if description
    puts ") at #{@base_offset} (#{@size} bytes)"
    print_extra_info(prefix + '|   ')
    @children.each { |box| box.print_tree(prefix + '|   ') }
  end
end

class BoxWithSubBoxes < BoxWithChildren
  handles 'ilst', "The iTunes/iPod Container Box"

  def read_data(stream)
    @data = stream.read(@data_size)
    @data_stream = StringIO.new(@data)

    read_header_data(@data_stream) if @data

    while (@data_stream.pos + 1) < (@data_stream.length) && (box = SubBox.read(@data_stream, :parent => self))
      @children << box
    end
  end

  def read_header_data(stream)
    # No default header data.
  end
end

class SubBoxWithSubBoxes < SubBox
  handles 'wave', 'Wave Audio Description'
  handles "----", "iTunes Freeform Metadata"
  handles "\xA9too", "Encoding Tool"
  handles 'sinf', 'Protection Scheme Info'
  handles 'schi', 'Scheme Information'

  def read_data(stream)
    @data = stream.read(@data_size)
    @data_stream = StringIO.new(@data)

    @content_is_tags = (@data_size >= 3 && @data[0,3] == [0x03,0x80,0x80].pack('C*'))

    if @content_is_tags
      parse_tags
    else
      read_header_data(@data_stream) if @data

      while (@data_stream.pos + 1) < (@data_stream.length) && (box = SubBox.read(@data_stream, :parent => self))
        @children << box
      end
    end
  end

  def print_extra_info(prefix = '')
    return unless @content_is_tags
    print prefix
    cputs "Object Type: #{@object_type}", :dark_gray
    print prefix
    cputs "Bitrate: #{@bitrate}", :dark_gray
    print prefix
    cputs "Max Bitrate: #{@max_bitrate}", :dark_gray
  end

  def read_header_data(stream)
    # No default header data.
  end

  def parse_tags(data_size = @data_size)
    while @data_stream.pos < data_size
      kind = @data_stream.ui8
      len = read_desc_length

      return if len == 0

      case kind
      when 3 # es_descr_tag -- has subitems.
        # 3 bytes are esid and stream priority
        @data_stream.read(3)
        parse_tags(len - 3)
      when 4 # decoder_config_descr_tag -- the one we want.
        @object_type = @data_stream.ui8
        @data_stream.ui32 # Unknown
        @max_bitrate = @data_stream.ui32
        @bitrate = @data_stream.ui32
        if len > 8
          @data_stream.read(len - 8)
        end
      when 5 # dec_specific_info_tag -- not useful
        @data_stream.read(len)
      when 6 # sl_config_descr_tag -- not useful
        @data_stream.read(len)
      else # who knows
        @data_stream.read(len)
      end

    end
  end

  def read_desc_length
    length = 0
    4.times do
      b = @data_stream.ui8
      length = (length << 7) + (b & 127)
      return length if b < 128
    end
    return length
  rescue
    0
  end
end

class FrmaBox < SubBox
  handles 'frma', 'Original Format'

  attr_accessor :format

  def read_data(stream)
    @format = stream.fourcc
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Format: #{@format}", :dark_gray
  end
end

class TencBox < SubBox
  handles 'tenc', 'Track Encryption'

  attr_accessor :version, :flags, :is_encrypted, :iv_length, :key_id

  def initialize(*args)
    @version = nil
    @flags = nil
    @is_encrypted = nil
    @iv_length = nil
    @key_id = nil
    super
  end

  def read_data(stream)
    @version, @flags = stream.ui8, stream.ui24
    @is_encrypted = stream.ui24
    @iv_size = stream.ui8
    @key_id = stream.read(16)
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Is Encrypted?: #{(@is_encrypted == 1) ? 'Yes' : 'No'}", :dark_gray
    if @is_encrypted > 1
      # Per 14496-12, amendment 3.
      print prefix
      cputs "  Algorithm ID: #{@is_encrypted}", :dark_gray
    end
    print prefix
    cputs "IV Size: #{@iv_size} bytes (#{@iv_size * 8} bits)", :dark_gray
    print prefix
    cputs "Key ID: #{@key_id.unpack('H*').first}", :dark_gray
  end
end

class SencBox < Box
  handles 'senc', 'Sample Encryption'

  attr_accessor :version, :flags, :sample_count

  def initialize(*args)
    @version = nil
    @flags = nil
    @sample_count = nil
    @samples = []
    super
  end

  def read_data(stream)
    @version, @flags = stream.ui8, stream.ui24
    @sample_count = stream.ui32

    if [8,16].include?(ENV['IV_SIZE'].to_i)
      iv_size = ENV['IV_SIZE'].to_i
    else
      # TODO: Assuming 8-byte IV here, but it could be 16-byte too.  Have to get
      # that data from 'tenc' box which could be in a separate init file.
      iv_size = 8
    end

    @sample_count.times do |index|
      sample_info = {}
      sample_info[:iv] = stream.read(iv_size)
      if (@flags & 2) == 2
        sample_info[:subsamples] = []
        sample_info[:subsample_count] = stream.ui16
        sample_info[:subsample_count].times do
          subsample_info = {}
          subsample_info[:bytes_clear_data] = stream.ui16
          subsample_info[:bytes_encrypted_data] = stream.ui32
          sample_info[:subsamples] << subsample_info
        end
      end
      @samples << sample_info
    end
  end

  def print_extra_info(prefix = '')
    if @sample_count != @samples.length
      print prefix
      cputs "Sample count (#{@sample_count}) doesn't match number of samples found (#{@samples.length})!", :red
    end
    print prefix
    cputs "Sample Count: #{@sample_count}", :dark_gray
    if $VERBOSE
      trun = parent.first_child('trun')
      @samples.each_with_index do |sample, index|
        print prefix
        cputs ("Sample %2d IV: #{sample[:iv].unpack('H*').first}" % (index + 1)), :dark_gray

        subsamples_total_size = 0
        (sample[:subsamples] || []).each_with_index do |subsample, subindex|
          subsamples_total_size += subsample[:bytes_clear_data] + subsample[:bytes_encrypted_data]
          print prefix
          cputs ("  Subsample %2d: bytes_clear = #{subsample[:bytes_clear_data]}, bytes_encrypted = #{subsample[:bytes_encrypted_data]}" % (subindex + 1)), :dark_gray
        end
        if sample[:subsamples] && trun.entries[index] && trun.entries[index][:size].to_i > 0 && trun.entries[index][:size].to_i != subsamples_total_size
          print prefix
          cputs "  Subsamples size does not match trun entry size!", :red
        end
      end
    end
  end
end

class SaioBox < Box
  handles 'saio', 'Sample Auxilliary Information Offsets'

  attr_accessor :version, :flags, :aux_info_type, :aux_info_type_parameter, :entry_count, :entries

  def initialize(*args)
    @version = nil
    @flags = nil
    @aux_info_type = nil
    @aux_info_type_parameter = nil
    super
  end

  def read_data(stream)
    @version,@flags = stream.ui8, stream.ui24

    if (@flags & 1) == 1
      @aux_info_type = stream.ui32
      @aux_info_type_parameter = stream.ui32
    end

    @entries = []
    @entry_count = stream.ui32
    @entry_count.times do
      if @version == 0
        @entries << stream.ui32
      else
        @entries << stream.ui64
      end
    end
  end

  def print_extra_info(prefix = '')
    if @aux_info_type
      print prefix
      cputs "Aux info type: #{@aux_info_type}", :dark_gray
      print prefix
      cputs "Aux info type parameter: #{@aux_info_type_parameter}", :dark_gray
    end
    print prefix
    cputs "Entry Count: #{@entry_count}", :dark_gray
    if $VERBOSE
      @entries.each_with_index do |entry, index|
        print prefix
        cputs "Offset #{index + 1}: #{entry}", :dark_gray
      end
    end
  end
end

class SaizBox < Box
  handles 'saiz', 'Sample Auxilliary Information Sizes'

  attr_accessor :version, :flags, :aux_info_type, :aux_info_type_parameter, :default_size, :entry_count, :entries

  def initialize(*args)
    @version = nil
    @flags = nil
    @aux_info_type = nil
    @aux_info_type_parameter = nil
    super
  end

  def read_data(stream)
    @version,@flags = stream.ui8, stream.ui24

    if (@flags & 1) == 1
      @aux_info_type = stream.ui32
      @aux_info_type_parameter = stream.ui32
    end

    @default_size = stream.ui8

    @entries = []
    @entry_count = stream.ui32

    if @default_size == 0
      @entry_count.times do
        @entries << stream.ui8
      end
    end
  end

  def print_extra_info(prefix = '')
    if @aux_info_type
      print prefix
      cputs "Aux info type: #{@aux_info_type}", :dark_gray
      print prefix
      cputs "Aux info type parameter: #{@aux_info_type_parameter}", :dark_gray
    end
    print prefix
    cputs "Default Sample Size: #{@default_size}", :dark_gray
    print prefix
    cputs "Entry Count: #{@entry_count}", :dark_gray
    if $VERBOSE
      @entries.each_with_index do |entry, index|
        print prefix
        cputs "Size #{index + 1}: #{entry}", :dark_gray
      end
    end
  end
end

class SchmBox < SubBox
  handles 'schm', 'Scheme Type'

  attr_accessor :version, :flags, :scheme, :scheme_version

  def initialize(*args)
    @version = nil
    @flags = nil
    @scheme = nil
    @scheme_version = nil
    # Might also be a UTF-8 Encoded URI here too.
    super
  end

  def read_data(stream)
    @version,@flags,@scheme,@scheme_version = stream.ui8, stream.ui24, stream.fourcc, stream.ui16
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Scheme: #{@scheme}", :dark_gray
    print prefix
    cputs "Scheme Version: #{@scheme_version}", :dark_gray
  end
end

class UuidBox < Box
  handles 'uuid', 'Extended Information'

  ALGORITHM_TYPES = ['Not Encrypted', 'AES-128-CTR', 'AES-128-CBC']
  SAMPLE_ENCRYPTION_TYPE = 'A2394F52-5A9B-4F14-A244-6C427C648DF4'
  PSSH_TYPE = 'D08A4F18-10F3-4A82-B6C8-32D8ABA183D3'

  SYSTEM_IDS = {
    '79F0049A-4098-8642-AB92-E65BE0885F95' => 'PlayReady Object v4.0.0.0',
    '9A04F079-9840-4286-AB92-E65BE0885F95' => 'PlayReady Object v4.1.0.0'
  }

  attr_accessor :version, :flags, :scheme, :scheme_version

  def initialize(*args)
    @extended_type = nil
    @version = nil
    @flags = nil
    @algorithm_id = nil
    @iv_size = nil
    @key_id = nil
    @system_id = nil
    @pssh_data_size = nil
    @pro_records = []
    @sample_count = nil
    @samples = []
    super
  end

  def read_data(stream)
    @extended_type,@version,@flags = stream.uuid, stream.ui8, stream.ui24

    if @extended_type == SAMPLE_ENCRYPTION_TYPE
      if (@flags & 1) == 1
        @algorithm_id,@iv_size,@key_id = stream.ui24, stream.ui8, stream.key128
      end
      @sample_count = stream.ui32

      if [8,16].include?(ENV['IV_SIZE'].to_i)
        default_iv_size = ENV['IV_SIZE'].to_i
      else
        # TODO: Assuming 8-byte IV here, but it could be 16-byte too.  Might have to get
        # that data from 'tenc' box which could be in a separate init file.
        default_iv_size = 8
      end

      @sample_count.times do |index|
        sample_info = {}
        sample_info[:iv] = stream.read(@iv_size || default_iv_size)
        if (@flags & 2) == 2
          sample_info[:subsamples] = []
          sample_info[:subsample_count] = stream.ui16
          sample_info[:subsample_count].times do
            subsample_info = {}
            subsample_info[:bytes_clear_data] = stream.ui16
            subsample_info[:bytes_encrypted_data] = stream.ui32
            sample_info[:subsamples] << subsample_info
          end
        end
        @samples << sample_info
      end

    elsif @extended_type == PSSH_TYPE
      @system_id, @pssh_data_size = stream.guid, stream.ui32

      # Decode PlayReady PRO header.
      if SYSTEM_IDS[@system_id].to_s =~ /^PlayReady/
        pro_length = stream.dword
        pro_record_count = stream.word
        pro_record_count.times do
          record_type = stream.word
          record_length = stream.word
          record_value = stream.read(record_length)
          decoded = {}

          if record_type == 1 # Rights Management Headers
            ascii = record_value.utf16_to_ascii
            decoded[:header_version] = $1 if ascii =~ /version="([^"]+)"/
            decoded[:keylen] = $1.to_i if ascii =~ /<KEYLEN>(\d+)<\/KEYLEN>/
            decoded[:algid] = $1 if ascii =~ /<ALGID>([^<]+)<\/ALGID>/
            decoded[:la_url] = $1 if ascii =~ /<LA_URL>([^<]+)<\/LA_URL>/
            decoded[:kid_base64] = $1 if ascii =~ /<KID>([^<]+)<\/KID>/
            decoded[:kid] = Base64.decode64(decoded[:kid_base64]).unpack('H*').first if decoded[:kid_base64]
          end

          @pro_records << {
            :type => ['Unknown','Rights Management Header','Reserved','Embedded License Store'][record_type] || 'Unknown',
            :size => record_length,
            :value => record_value,
            :empty => record_value.to_s.gsub(/\x00/n,'').length == 0,
            :decoded => decoded
          }
        end
      end
    end
  end

  def print_extra_info(prefix = '')
    if @extended_type == SAMPLE_ENCRYPTION_TYPE
      print prefix
      cputs "Extended Type: Sample Encryption Box", :dark_gray
      print prefix
      cputs "Overrides TrackEncryptionBox parameters: #{((@flags & 1) == 1) ? 'Yes' : 'No'}", :dark_gray
      print prefix
      cputs "Uses Subsample Encryption: #{((@flags & 2) == 2) ? 'Yes' : 'No'}", :dark_gray
      if (@flags & 1) == 1
        print prefix
        cputs "Algorithm ID: #{@algorithm_id} (#{ALGORITHM_TYPES[@algorithm_id] || 'Unknown'})", :dark_gray
        print prefix
        cputs "IV Size: #{@iv_size}", :dark_gray
        print prefix
        cputs "Key ID: #{@key_id}", :dark_gray
      end
      if @sample_count != @samples.length
        print prefix
        cputs "Sample count (#{@sample_count}) doesn't match number of samples found (#{@samples.length})!", :red
      end
      print prefix
      cputs "Sample Count: #{@sample_count}", :dark_gray
      if $VERBOSE
        trun = parent.first_child('trun')

        @samples.each_with_index do |sample, index|
          print prefix
          cputs ("Sample %2d IV: #{sample[:iv].unpack('H*').first}" % (index + 1)), :dark_gray

          subsamples_total_size = 0
          (sample[:subsamples] || []).each_with_index do |subsample, subindex|
            subsamples_total_size += subsample[:bytes_clear_data] + subsample[:bytes_encrypted_data]
            print prefix
            cputs ("  Subsample %2d: bytes_clear = #{subsample[:bytes_clear_data]}, bytes_encrypted = #{subsample[:bytes_encrypted_data]}" % (subindex + 1)), :dark_gray
          end
          if sample[:subsamples] && trun && trun.entries[index] && trun.entries[index][:size].to_i > 0 && trun.entries[index][:size].to_i != subsamples_total_size
            print prefix
            cputs "  Subsamples size does not match trun entry size!", :red
          end
        end
      end

    elsif @extended_type == PSSH_TYPE
      print prefix
      cputs "Extended Type: PSSH (Protection System Specific Header) Box", :dark_gray
      print prefix
      cputs "System ID: #{@system_id} (#{SYSTEM_IDS[@system_id] || 'Unknown'})", :dark_gray

      if SYSTEM_IDS[@system_id].to_s =~ /^PlayReady/
        @pro_records.each do |pro|
          print prefix
          cputs "PlayReady Header Object: #{pro[:type]}#{' (Empty)' if pro[:empty]}", :dark_gray

          pro[:decoded].keys.sort.each do |key|
            print prefix
            cputs "  #{key}: #{pro[:decoded][key]}", :dark_gray
          end

          if $VERBOSE && pro[:type] == 'Rights Management Header'
            print prefix
            cputs "Header Object Value: #{pro[:value]}", :dark_gray
          end
        end
      end

    else
      print prefix
      cputs "Extended Type: #{@extended_type} (Unknown)", :dark_gray
    end
  end
end

class UuidSubBox < SubBox
  handles 'uuid', 'Extended Information'

  ALGORITHM_TYPES = ['Not Encrypted', 'AES-128-CTR', 'AES-128-CBC']
  TRACK_ENCRYPTION_TYPE = '8974DBCE-7BE7-4C51-84F9-7148F9882554'

  attr_accessor :version, :flags, :scheme, :scheme_version

  def initialize(*args)
    @extended_type = nil
    @version = nil
    @flags = nil
    @algorithm_id = nil
    @iv_size = nil
    @key_id = nil
    super
  end

  def read_data(stream)
    @extended_type,@version,@flags = stream.uuid, stream.ui8, stream.ui24

    if @extended_type == TRACK_ENCRYPTION_TYPE
      @algorithm_id,@iv_size,@key_id = stream.ui24, stream.ui8, stream.key128
    end
  end

  def print_extra_info(prefix = '')
    if @extended_type == TRACK_ENCRYPTION_TYPE
      print prefix
      cputs "Extended Type: Track Encryption Box", :dark_gray
      print prefix
      cputs "Algorithm ID: #{@algorithm_id} (#{ALGORITHM_TYPES[@algorithm_id] || 'Unknown'})", :dark_gray
      print prefix
      cputs "IV Size: #{@iv_size}", :dark_gray
      print prefix
      cputs "Key ID: #{@key_id}", :dark_gray
    else
      print prefix
      cputs "Extended Type: #{@extended_type} (Unknown)", :dark_gray
    end
  end
end

class StsdBox < BoxWithSubBoxes
  handles 'stsd', 'Sample Descriptions'

  attr_accessor :version, :entry_count

  def initialize(*args)
    @version = nil
    super
  end

  def read_header_data(stream)
    @version,@entry_count = stream.ui32, stream.ui32
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Version: #{@version}", :dark_gray
    print prefix
    cputs "Entry Count: #{@entry_count}", :dark_gray
  end
end

class SttsBox < Box
  handles 'stts', 'Sample to (Decode) Time'

  attr_accessor :version, :flags, :entry_count, :entries

  def initialize(*args)
    @version = nil
    @flags = nil
    @entry_count = 0
    @entries = []
    super
  end

  def read_data(stream)
    @version,@flags,@entry_count = stream.ui8, stream.ui24, stream.ui32
    time_offset = 0
    sample_offset = 0

    # Read the entries, but cache extra information for quick lookups of sample times.
    @entry_count.times do |i|
      count = stream.ui32
      duration = stream.ui32
      @entries << {
        :count => count,
        :duration => duration,
        :sample_offset => sample_offset,
        :time_offset => time_offset
      }
      sample_offset += count
      time_offset += count*duration
    end
  end

  def print_extra_info(prefix = '')
    if @entry_count != @entries.length
      print prefix
      cputs "Entry count doesn't match number of entries found!", :red
    end
    print prefix
    cputs "Entry Count: #{@entry_count}", :dark_gray
    if $VERBOSE
      @entries.each do |entry|
        print prefix
        cputs "Sample Count: #{entry[:count]}, Duration: #{entry[:duration]}", :dark_gray
      end
    end
  end

  def lookup_sample_time_in_seconds(sample_number)
    @timescale ||= find_parent('mdia').first_child('mdhd').timescale rescue nil
    if @timescale
      sample_time = lookup_sample_time(sample_number)
      if sample_time
        sample_time.to_f / @timescale
      end
    end
  end

  def lookup_sample_time(sample_number)
    sample_index = sample_number - 1
    entry = @entries.detect { |e| e[:sample_offset] <= sample_index && (e[:sample_offset] + e[:count] - 1) >= sample_index }
    if entry
      entry[:time_offset] + (sample_index - entry[:sample_offset]) * entry[:duration]
    else
      nil
    end
  end

end

class CslgBox < Box
  handles 'cslg', 'Composition Shift Least Greatest'

  attr_accessor :version, :flags

  def initialize(*args)
    @version = nil
    @flags = nil
    @shift = nil
    @least_delta = nil
    @greatest_delta = nil
    @display_start_time = nil
    @display_end_time = nil
    super
  end

  def read_data(stream)
    @version,@flags = stream.ui8, stream.ui24
    @shift, @least_delta, @greatest_delta = stream.si32, stream.si32, stream.si32
    @display_start_time, @display_end_time = stream.ui32, stream.ui32
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Shift: #{@shift}", :dark_gray
    print prefix
    cputs "Least Delta: #{@least_delta}", :dark_gray
    print prefix
    cputs "Greatest Delta: #{@greatest_delta}", :dark_gray
    print prefix
    cputs "Display Start Time: #{@display_start_time}", :dark_gray
    print prefix
    cputs "Display End Time: #{@display_end_time}", :dark_gray
  end
end

class CttsBox < Box
  handles 'ctts', 'Composition Time Offsets'

  attr_accessor :version, :flags, :entry_count, :entries

  def initialize(*args)
    @version = nil
    @flags = nil
    @entry_count = 0
    @entries = []
    super
  end

  def read_data(stream)
    @version,@flags,@entry_count = stream.ui8, stream.ui24, stream.ui32
    @entry_count.times do |i|
      @entries << { :count => stream.ui32, :offset => stream.si32 }
    end
  end

  def print_extra_info(prefix = '')
    if @entry_count != @entries.length
      print prefix
      cputs "Entry count doesn't match number of entries found!", :red
    end
    print prefix
    cputs "Entry Count: #{@entry_count}", :dark_gray

    if $VERBOSE
      stts = find_parent('stbl').first_child('stts') rescue nil
      stts_entries = stts.entries rescue []
      stts_index = 0
      stts_sample_count = 0
      stts_entry = stts_entries[stts_index]

      @entries.each do |entry|
        if stts_entry
          entry[:count].times do |entry_subitem|
            dts = stts_entry[:time_offset] + stts_sample_count * stts_entry[:duration]
            pts = dts + entry[:offset]
          
            print prefix
            if entry_subitem > 0
              cputs "                 Offset: #{entry[:offset].to_s.rjust(5)}, DTS: #{dts}, PTS: #{pts}, DUR: #{stts_entry[:duration]}", :dark_gray
            else
              cputs "Sample Count: #{entry[:count]}, Offset: #{entry[:offset].to_s.rjust(5)}, DTS: #{dts}, PTS: #{pts}, DUR: #{stts_entry[:duration]}", :dark_gray
            end

            stts_sample_count += 1
            if stts_sample_count >= stts_entry[:count]
              stts_index += 1
              stts_entry = stts_entries[stts_index]
              stts_sample_count = 0
            end
          end
        else
          print prefix
          cputs "Sample Count: #{entry[:count]}, Offset: #{entry[:offset].to_s.rjust(5)}", :dark_gray
        end
      end
    end
  end

end

class SdtpBox < Box
  handles 'sdtp', 'Sample Dependency Box'

  attr_accessor :version, :flags, :entry_count, :entries

  def initialize(*args)
    @version = nil
    @flags = nil
    @sample_count = nil
    @entries = []
    @entry_count = nil
    @implicit_entry_count = false
    super
  end

  def read_data(stream)
    @version,@flags = stream.ui8, stream.ui24
    @entry_count = lookup_sample_count rescue -1
    if @entry_count < 0
      @implicit_entry_count = true
      @entry_count = (@data_size - 4)
    end
    @entry_count.times do
      flags = stream.ui8
      @entries << {
        :depends_on => (flags & 0b00110000) >> 4,
        :depended_on => (flags & 0b00001100) >> 2,
        :redundancy => (flags & 0b00000011),
      }
    end
  end

  def print_extra_info(prefix = '')
    value_names = ['Unknown','Yes',' No','Invalid/Reserved']
    if @implicit_entry_count
      print prefix
      cputs "File order required using implicit entry count.", :red
    end
    print prefix
    cputs "Entry Count: #{@entry_count}", :dark_gray
    if $VERBOSE
      @entries.each_with_index do |entry,i|
        print prefix
        cputs "Sample #{i+1}: Depends On Others: #{value_names[entry[:depends_on]]}, Depended On By Others: #{value_names[entry[:depended_on]]}, Has Redundancy: #{value_names[entry[:redundancy]]}", :dark_gray
      end
    end
  end

  def lookup_sample_count
    return @sample_count if @sample_count
    temp_parent = find_parent('stbl') || find_parent('traf') #rescue nil
    raise "No parent for sdtp found -- unknown sample count." unless parent
    count_child = parent.first_child('stsz') || parent.first_child('trun')
    raise "No stsz or trun found matching sdtp -- unknown sample count." unless count_child
    @sample_count = count_child.entry_count
  end
end

class StscBox < Box
  handles 'stsc', 'Sample to Chunk'

  attr_accessor :version, :flags, :entry_count, :entries

  def initialize(*args)
    @version = nil
    @flags = nil
    @entry_count = 0
    @entries = []
    super
  end

  def read_data(stream)
    @version,@flags,@entry_count = stream.ui8, stream.ui24, stream.ui32
    @entry_count.times do |i|
      @entries << { :first_chunk => stream.ui32, :samples => stream.ui32, :description => stream.ui32 }
    end
  end

  def print_extra_info(prefix = '')
    if @entry_count != @entries.length
      print prefix
      cputs "Entry count doesn't match number of entries found!", :red
    end
    print prefix
    cputs "Entry Count: #{@entry_count}", :dark_gray
    if $VERBOSE
      @entries.each do |entry|
        print prefix
        cputs "First Chunk: #{entry[:first_chunk]}, Samples: #{entry[:samples]}, Desc: #{entry[:description]}", :dark_gray
      end
    end
  end

end

class StcoBox < Box
  handles 'stco', 'Chunk Offset Table'

  attr_accessor :version, :flags, :entry_count, :entries

  def initialize(*args)
    @version = nil
    @flags = nil
    @entry_count = 0
    @entries = []
    super
  end

  def read_data(stream)
    @version,@flags,@entry_count = stream.ui8, stream.ui24, stream.ui32
    @entry_count.times do |i|
      @entries << stream.ui32
    end
  end

  def print_extra_info(prefix = '')
    if @entry_count != @entries.length
      print prefix
      cputs "Entry count doesn't match number of entries found!", :red
    end
    print prefix
    cputs "Entry Count: #{@entry_count}", :dark_gray
    if $VERBOSE2
      @entries.each do |entry|
        print prefix
        cputs "Chunk Offset: #{entry}", :dark_gray
      end
    end
  end

end

class Co64Box < Box
  handles 'co64', '64-bit Chunk Offset Table'

  attr_accessor :version, :flags, :entry_count, :entries

  def initialize(*args)
    @version = nil
    @flags = nil
    @entry_count = 0
    @entries = []
    super
  end

  def read_data(stream)
    @version,@flags,@entry_count = stream.ui8, stream.ui24, stream.ui32
    @entry_count.times do |i|
      @entries << stream.ui64
    end
  end

  def print_extra_info(prefix = '')
    if @entry_count != @entries.length
      print prefix
      cputs "Entry count doesn't match number of entries found!", :red
    end
    print prefix
    cputs "Entry Count: #{@entry_count}", :dark_gray
    if $VERBOSE2
      @entries.each do |entry|
        print prefix
        cputs "Chunk Offset: #{entry}", :dark_gray
      end
    end
  end

end

class StszBox < Box
  handles 'stsz', 'Sample Sizes'

  attr_accessor :version, :flags, :entry_count, :entries

  def initialize(*args)
    @version = nil
    @flags = nil
    @sample_size = 0
    @entry_count = 0
    @entries = []
    super
  end

  def read_data(stream)
    @version,@flags,@sample_size,@entry_count = stream.ui8, stream.ui24, stream.ui32, stream.ui32
    if @sample_size == 0
      @entry_count.times do |i|
        @entries << stream.ui32
      end
    end
  end

  def print_extra_info(prefix = '')
    if @entry_count != @entries.length && @sample_size == 0
      print prefix
      cputs "Entry count doesn't match number of entries found!", :red
    end
    print prefix
    cputs "Default Sample Size: #{@sample_size}", :dark_gray
    print prefix
    cputs "Entry Count: #{@entry_count}", :dark_gray
    if $VERBOSE2
      @entries.each do |entry|
        print prefix
        cputs "Sample Size: #{entry}", :dark_gray
      end
    end
  end

end

class StssBox < Box
  handles 'stss', 'Sync Samples'

  attr_accessor :version, :flags, :entry_count, :entries

  def initialize(*args)
    @version = nil
    @flags = nil
    @entry_count = 0
    @entries = []
    super
  end

  def read_data(stream)
    @version,@flags,@entry_count = stream.ui8, stream.ui24, stream.ui32
    @entry_count.times do |i|
      @entries << stream.ui32
    end
  end

  def print_extra_info(prefix = '')
    stts = find_parent('stbl').first_child('stts')
    if @entry_count != @entries.length
      print prefix
      cputs "Entry count doesn't match number of entries found!", :red
    end
    print prefix
    cputs "Entry Count: #{@entry_count}", :dark_gray
    if $VERBOSE
      @entries.each do |entry|
        print prefix
        if stts && (in_seconds = stts.lookup_sample_time_in_seconds(entry))
          cputs("Sample Number: #{entry} (%0.3f seconds)" % in_seconds, :dark_gray)
        else
          cputs "Sample Number: #{entry}", :dark_gray
        end
      end
    end
  end

end

class VmhdBox < Box
  handles 'vmhd', 'Video Media Info Header'

  attr_accessor :version, :flags, :graphics_mode, :color

  def initialize(*args)
    @version = nil
    @flags = nil
    @graphics_mode = nil
    @color = nil
    super
  end

  def read_data(stream)
    @version,@flags = stream.ui8, stream.ui24
    @graphics_mode = stream.ui16
    @color = stream.ui24
  end

  def mode_name(mode)
    {
      0x0000 => 'Copy',
      0x0040 => 'Dither Copy',
      0x0100 => 'Straight Alpha',
      0x0103 => 'Composition Dither Copy',
      0x0020 => 'Blend',
      0x0101 => 'Premultiplied White Alpha',
      0x0102 => 'Premultiplied Black Alpha',
      0x0024 => 'Transparent',
      0x0104 => 'Alpha Blend'
    }[mode] || 'Unknown'
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Graphics Mode: #{mode_name(@graphics_mode)}", :dark_gray
  end

end

class SmhdBox < Box
  handles 'smhd', 'Sound Media Info Header'

  attr_accessor :version, :flags, :balance

  def initialize(*args)
    @version = nil
    @flags = nil
    @balance = 0.0
    super
  end

  def read_data(stream)
    @version,@flags = stream.ui8, stream.ui24
    @balance = stream.fixed16
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs ("Balance: %0.3f" % @balance), :dark_gray
  end

end

class ElstBox < Box
  handles 'elst', 'Edit List'

  attr_accessor :version, :flags, :entry_count, :entries

  def initialize(*args)
    @version = nil
    @flags = nil
    @entry_count = 0
    @entries = []
    super
  end

  def read_data(stream)
    @version,@flags,@entry_count = stream.ui8, stream.ui24, stream.ui32
    @entry_count.times do |i|
      if @version == 1
        @entries << { :duration => stream.ui64, :media_time => stream.si64, :media_rate => stream.fixed32 }
      else
        @entries << { :duration => stream.ui32, :media_time => stream.si32, :media_rate => stream.fixed32 }
      end
    end
  end

  def print_extra_info(prefix = '')
    if @entry_count != @entries.length
      print prefix
      cputs "Entry count doesn't match number of entries found!", :red
    end

    movie_timescale = find_parent('moov').first_child('mvhd').timescale rescue nil

    # Unfortunately the media header generally comes after the edit lists, so we rarely can get the
    # media times for these.  :(
    media_timescale = find_parent('trak').first_child('mdh').timescale rescue nil

    total_duration = 0

    print prefix
    cputs "Entry Count: #{@entry_count}", :dark_gray
    @entries.each do |entry|
      total_duration += entry[:duration]

      extra = ''
      if movie_timescale
        if media_timescale
          extra = " (%0.3fs @ %0.3f)" % ([entry[:duration].to_f / movie_timescale, entry[:media_time].to_f / media_timescale])
        else
          extra = " (%0.3fs duration)" % (entry[:duration].to_f / movie_timescale)
        end
      end

      print prefix
      cputs "Duration: #{entry[:duration]}, Media Time: #{entry[:media_time]}, Media Rate: #{entry[:media_rate]}#{extra}", :dark_gray
    end

    if movie_timescale
      print prefix
      cputs("Total Duration: %0.3f seconds" % (total_duration.to_f / movie_timescale), :dark_gray)
    end
  end

end

class Mp4aSubBox < SubBoxWithSubBoxes
  handles 'mp4a', 'MP4 Audio Description'
  handles 'sowt', 'SOWT Audio Description'
  handles 'twos', 'TWOS Audio Description'
  handles 'aace', 'AACE Audio Description'

  handles 'enca', 'Encrypted Audio Description'

  attr_accessor :channels, :sample_size, :sample_rate

  def read_header_data(stream)
    return if @data_size < 16

    reserved1 = @data_stream.si32
    reserved2 = @data_stream.si16
    data_ref_index = @data_stream.si16
    version = @data_stream.si16
    revision = @data_stream.si16
    vendor = @data_stream.si32

    if version == 0 || version == 1
      @channels = @data_stream.si16
      @sample_size = @data_stream.si16
      compression_id = @data_stream.si16 # Unused
      packet_size = @data_stream.si16 # Unused
      @sample_rate = @data_stream.ui16 + (@data_stream.ui16 / 65536.0) # 16.16 fixed-point

      if version == 1 && (kind != 'alac' || @data_size > 100)
        samples_per_packet = @data_stream.ui32
        bytes_per_packet = @data_stream.ui32
        bytes_per_frame = @data_stream.ui32
        bytes_per_sample = @data_stream.ui32
      end

    elsif version == 2

      always3 = @data_stream.si16
      always16 = @data_stream.si16
      always_minus2 = @data_stream.si16
      always0 = @data_stream.si16
      always65536 = @data_stream.ui32

      size_of_struct = @data_stream.ui32

      @sample_rate = @data_stream.f64
      @channels = @data_stream.ui32
      always7f000000 = @data_stream.si32
      @sample_size = @data_stream.ui32
      format_specific_flags = @data_stream.ui32
      bytes_per_packet = @data_stream.ui32
      lpcm_frames_per_packet = @data_stream.ui32

    end
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Channels: #{@channels}", :dark_gray
    print prefix
    cputs "Sample Size: #{@sample_size}", :dark_gray
    print prefix
    cputs "Sample Rate: #{@sample_rate}", :dark_gray
  end
end

# handles 'tfra', 'Track Fragment Random Access'
# handles 'mfro', 'Movie Fragment Random Access Offset'

class TfraBox < Box
  handles 'tfra', 'Track Fragment Random Access'

  attr_accessor :version, :flags, :track_id, :entry_count, :entries

  SIZE_READ_METHODS = {
    0 => :ui8,
    1 => :ui16,
    2 => :ui24,
    3 => :ui32
  }

  def initialize(*args)
    @version = nil
    @flags = nil
    @track_id = nil
    @entry_count = nil
    @entries = []
    super
  end

  def read_data(stream)
    @version,@flags = stream.ui8, stream.ui24
    @track_id = stream.ui32
    length_sizes = stream.ui32
    size_of_traf_num = (length_sizes & 0b110000) >> 4
    size_of_trun_num = (length_sizes & 0b1100) >> 2
    size_of_sample_num = (length_sizes & 0b11)
    @entry_count = stream.ui32
    @entry_count.times do
      entry = {}
      if @version == 1
        entry[:time] = stream.ui64
        entry[:moof_offset] = stream.ui64
      else
        entry[:time] = stream.ui32
        entry[:moof_offset] = stream.ui32
      end
      entry[:traf_number] = stream.send(SIZE_READ_METHODS[size_of_traf_num])
      entry[:trun_number] = stream.send(SIZE_READ_METHODS[size_of_trun_num])
      entry[:sample_number] = stream.send(SIZE_READ_METHODS[size_of_sample_num])
      @entries << entry
    end
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Entry Count: #{@entry_count}", :dark_gray

    if $VERBOSE
      @entries.each do |entry|
        print prefix
        cputs "Entry Info: #{entry.inspect}", :dark_gray
      end
    end
  end
end

class MfroBox < Box
  handles 'mfro', 'Movie Fragment Random Access Offset'

  attr_accessor :version, :flags, :size

  def initialize(*args)
    @version = nil
    @flags = nil
    @mfra_size = nil
    super
  end

  def read_data(stream)
    @version,@flags,@mfra_size = stream.ui8, stream.ui24, stream.ui32
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "mfra Size: #{@mfra_size}", :dark_gray
  end
end

class IlstDataBox < SubBox
  handles "name", "iTunes Freeform Metadata Name"
  handles "mean", "iTunes Freeform Metadata Meaning"
  handles "data", "iTunes Freeform Metadata Data"

  attr_accessor :value

  def read_data(stream)
    super
    @value = nil

    return unless @data

    case @kind
    when 'data'
      @value = @data[8..-1]
    when 'name','mean'
      @value = @data[4..-1]
    end
  end

  def print_extra_info(prefix = '')
    if @value
      print prefix
      cputs "Value: #{@value}", :dark_gray

      if @kind == 'data' && @value.to_s =~ /^ 00000000 /
        name_atom = parent.first_child('name')
        if name_atom.nil? || name_atom.value == 'iTunSMPB'
          values = @value.strip.split
          print prefix
          cputs "Priming:   #{values[1].to_i(16)}", :dark_gray
          print prefix
          cputs "Remainder: #{values[2].to_i(16)}", :dark_gray
          print prefix
          cputs "Samples:   #{values[3].to_i(16)}", :dark_gray
        end
      end
    end
  end
end

class AlacSubBox < SubBox
  handles 'alac', 'ALAC Audio Description'

  attr_accessor :channels, :sample_size, :sample_rate

  class << self
    def new (*args)
      return Mp4aSubBox.new(*args) if args[3][:parent].kind == 'stsd'
      super
    end
  end

  def read_header_data(stream)
    return if @data_size < 16

    if @data_size == 12
    else
      version_flags = @data_stream.ui32

      ###

      frame_length = @data_stream.ui32
      compatible_version = @data_stream.ui8
      @bit_depth = @data_stream.ui8
      pb = @data_stream.ui8
      mb = @data_stream.ui8
      kb = @data_stream.ui8
      @channels = @data_stream.ui8
      max_run = @data_stream.ui16
      max_frame_bytes = @data_stream.ui32
      average_bitrate = @data_stream.ui32
      @sample_rate = @data_stream.ui32

      if @data_size >= 52
        # Also have channel layout info...
        # typedef struct ALACChannelLayoutInfo
        # {
        #         uint32_t        channelLayoutInfoSize;
        #         uint32_t        channelLayoutInfoID;
        #         uint32_t        versionFlags;
        #         uint32_t        channelLayoutTag;
        #         uint32_t        reserved1;
        #         uint32_t        reserved2;
        # } ALACChannelLayoutInfo;
      end

    end

  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Channels: #{@channels}", :dark_gray
    print prefix
    cputs "Bit Depth: #{@bit_depth}", :dark_gray
    print prefix
    cputs "Sample Rate: #{@sample_rate}", :dark_gray
  end
end

class Mp4vSubBox < SubBoxWithSubBoxes
  handles 'mp4v', 'MP4 Video Description'
  handles 'avc1', 'H264 Video Description'
  handles 'hvc1', 'HEVC Video Description'
  handles 'jpeg', 'JPEG Video Description'
  handles 'hdva', 'HDV Video Description'

  handles 'encv', 'Encrypted Video Description'

  SPECIAL_BIT_DEPTH_NAMES = {
    33 => "Black and White",
    34 => "4-Level Grayscale (2 bit)",
    36 => "16-Level Grayscale (4 bit)",
    40 => "256-Level Grayscale (8 bit)"
  }

  attr_accessor :width, :height, :frame_count, :depth

  def read_header_data(stream)
    reserved1 = @data_stream.si32
    reserved2 = @data_stream.si16
    data_ref_index = @data_stream.si16

    always0 = @data_stream.ui16    # Quicktime Video Encoding Version
    reserved3 = @data_stream.ui16  # Quicktime Video Encoding Revision Level
    always0 = @data_stream.ui32    # Quicktime Video Encoding Vendor
    always0 = @data_stream.ui32    # Quicktime Video Temporal Quality
    always0 = @data_stream.ui32    # Quicktime Video Spatial Quality
    @width = @data_stream.ui16
    @height = @data_stream.ui16
    horizontal_ppi = @data_stream.fixed32
    vertical_ppi = @data_stream.fixed32
    reserved4 = @data_stream.ui32           # Quicktime Video Data Size
    @frame_count = @data_stream.ui16        # Frames per sample
    compressor_name = @data_stream.read(32)
    @depth = @data_stream.ui16
    alwaysMinus1 = @data_stream.si16        # Quicktime video color table ID (-1 if no table)
    # Could be trailing color table data here, if color table ID is zero.
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Width: #{@width}", :dark_gray
    print prefix
    cputs "Height: #{@height}", :dark_gray
    if $VERBOSE
      print prefix
      cputs "Frame Count: #{@frame_count}", :dark_gray
      print prefix
      bit_depth_name = " (#{SPECIAL_BIT_DEPTH_NAMES[@depth]})" if SPECIAL_BIT_DEPTH_NAMES[@depth]
      cputs "Depth: #{@depth}#{bit_depth_name}", :dark_gray
    end
  end
end

class Mp4sSubBox < SubBoxWithSubBoxes
  handles 'mp4s', 'MP4 Stream Description'

  attr_accessor :width, :height

  def read_header_data(stream)
    reserved1 = @data_stream.si32
    reserved2 = @data_stream.si16
    data_ref_index = @data_stream.si16
  end

end

class EsdsSubBox < SubBox
  handles 'esds', 'Extended Sample Description'

  attr_reader :max_bitrate, :bitrate, :audio_type

  MPEG4_DESCRIPTOR_OBJECT_TYPES = {
    1   => 'System V1',
    2   => 'System V2',
    32  => 'MPEG-4 Video',
    33  => 'MPEG-4 AVC SPS',
    34  => 'MPEG-4 AVC PPS',
    64  => 'MPEG-4 Audio',
    96  => 'MPEG-2 Simple Video',
    97  => 'MPEG-2 Main Video',
    98  => 'MPEG-2 SNR Video',
    99  => 'MPEG-2 Spatial Video',
    100 => 'MPEG-2 High Video',
    101 => 'MPEG-2 4:2:2 Video',
    102 => 'MPEG-4 ADTS Main',
    103 => 'MPEG-4 ADTS Low Complexity',
    104 => 'MPEG-4 ADTS Scalable Sampling Rate',
    105 => 'MPEG-2 ADTS',
    106 => 'MPEG-1 Video',
    107 => 'MPEG-1 ADTS',
    108 => 'JPEG Video',
    192 => 'Private Audio',
    208 => 'Private Video',
    224 => '16-bit PCM Little-Endian Audio',
    225 => 'Vorbis Audio',
    226 => 'Dolby V3 (AC3) Audio',
    227 => 'A-Law Audio',
    228 => 'Mu-Law Audio',
    229 => 'G723 ADPCM Audio',
    230 => '16-bit PCM Big-Endian Audio',
    240 => 'YCbCr 4:2:0 (YV12) Video',
    241 => 'H.264 Video',
    242 => 'H.263 Video',
    243 => 'H.261 Video'
  }

  MPEG4_AUDIO_OBJECT_TYPES = {
    0 => "Null",
    1 => "AAC Main",
    2 => "AAC LC (Low Complexity)",
    3 => "AAC SSR (Scalable Sample Rate)",
    4 => "AAC LTP (Long Term Prediction)",
    5 => "SBR (Spectral Band Replication)",
    6 => "AAC Scalable",
    7 => "TwinVQ",
    8 => "CELP (Code Excited Linear Prediction)",
    9 => "HXVC (Harmonic Vector eXcitation Coding)",
    10 => "Reserved",
    11 => "Reserved",
    12 => "TTSI (Text-To-Speech Interface)",
    13 => "Main Synthesis",
    14 => "Wavetable Synthesis",
    15 => "General MIDI",
    16 => "Algorithmic Synthesis and Audio Effects",
    17 => "ER (Error Resilient) AAC LC",
    18 => "Reserved",
    19 => "ER AAC LTP",
    20 => "ER AAC Scalable",
    21 => "ER TwinVQ",
    22 => "ER BSAC (Bit-Sliced Arithmetic Coding)",
    23 => "ER AAC LD (Low Delay)",
    24 => "ER CELP",
    25 => "ER HVXC",
    26 => "ER HILN (Harmonic and Individual Lines plus Noise)",
    27 => "ER Parametric",
    28 => "SSC (SinuSoidal Coding)",
    29 => "PS (Parametric Stereo)",
    30 => "MPEG Surround",
    31 => "(Escape value)",
    32 => "Layer-1",
    33 => "Layer-2",
    34 => "Layer-3",
    35 => "DST (Direct Stream Transfer)",
    36 => "ALS (Audio Lossless)",
    37 => "SLS (Scalable LosslesS)",
    38 => "SLS non-core",
    39 => "ER AAC ELD (Enhanced Low Delay)",
    40 => "SMR (Symbolic Music Representation) Simple",
    41 => "SMR Main",
    42 => "USAC (Unified Speech and Audio Coding) (no SBR)",
    43 => "SAOC (Spatial Audio Object Coding)",
    44 => "LD MPEG Surround",
    45 => "USAC"
  }

  MPEG4_AUDIO_FREQUENCIES = {
    0 => "96000",
    1 => "88200",
    2 => "64000",
    3 => "48000",
    4 => "44100",
    5 => "32000",
    6 => "24000",
    7 => "22050",
    8 => "16000",
    9 => "12000",
    10 => "11025",
    11 => "8000",
    12 => "7350",
    13 => "Reserved",
    14 => "Reserved"
  }  

  MPEG4_CHANNEL_CONFIGURATIONS = {
    0 => "Defined in AOT Specifc Config",
    1 => "1 channel - Center",
    2 => "2 channels - Left, Right",
    3 => "3 channels - Center, Left, Right",
    4 => "4 channels - C, L, R rear_C",
    5 => "5 channels - C, L, R rear_L, rear_R",
    6 => "6 channels - C, L, R rear_L, rear_R, LFE",
    7 => "8 channels - C, L, R side_L, side_R, rear_L, rear_R, LFE"
  }

  MPEG4_VISUAL_VIDEO_FORMATS = {
    0 => "Component",
    1 => "PAL",
    2 => "NTSC",
    3 => "SECAM",
    4 => "MAC",
    5 => "Unspecified video format"
  }
  MPEG4_VISUAL_VIDEO_FORMATS.default = "Reserved"

  MPEG4_VISUAL_VIDEO_RANGES = {
    0 => "Studio",
    1 => "Full"
  }

  MPEG4_VISUAL_COLOR_PRIMARIES = {
    0 => "Forbidden",
    1 => "BT.709",
    2 => "Unspecified Video",
    3 => "Reserved",
    4 => "BT.470 System M",
    5 => "BT.470 System B and G, BT.601 625",
    6 => "SMPTE 170M, BT.601 525",
    7 => "SMPTE 240M",
    8 => "Generic film"
  }
  MPEG4_VISUAL_COLOR_PRIMARIES.default = "Reserved"

  MPEG4_VISUAL_TRANSFER_CHARACTERISTICS = {
    0 => "Forbidden",
    1 => "BT.709",
    2 => "Unspecified Video",
    3 => "Reserved",
    4 => "BT.470 System M",
    5 => "BT.470 System B and G",
    6 => "SMPTE 170M, BT.601 525, BT.601 625",
    7 => "SMPTE 240M",
    8 => "Linear",
    9 => "Logarithmic (100:1)",
    10 => "Logarithmic (316.22777:1)"
  }
  MPEG4_VISUAL_TRANSFER_CHARACTERISTICS.default = "Reserved"

  MPEG4_VISUAL_MATRIX_COEFFICIENTS = {
    0 => "Forbidden",
    1 => "BT.709",
    2 => "Unspecified Video",
    3 => "Reserved",
    4 => "FCC",
    5 => "BT.470-2 System B and G, BT.601 625",
    6 => "SMPTE 170M, BT.601 525",
    7 => "SMPTE 240M"
  }
  MPEG4_VISUAL_MATRIX_COEFFICIENTS.default = "Reserved"

  def read_data(stream)
    super
    return unless @data

    @core_coder_delay = nil
    @audio_object_type = nil
    @video_format = nil
    @video_range = nil
    @color_primaries = nil
    @transfer_characteristics = nil
    @matrix_coefficients = nil

    version = @data_stream.ui8
    flags = @data_stream.ui24

    parse_tags if @data
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Object Type: #{@object_type} - #{MPEG4_DESCRIPTOR_OBJECT_TYPES[@object_type] || 'Unknown'}", :dark_gray
    print prefix
    cputs "Buffer Size: #{@buffer_size}", :dark_gray
    print prefix
    cputs "Bitrate: #{@bitrate}", :dark_gray
    print prefix
    cputs "Max Bitrate: #{@max_bitrate}", :dark_gray
    if @audio_object_type
      print prefix
      cputs "Audio Specifc Config:", :dark_gray
      print prefix
      cputs "  Audio Object Type: #{@audio_object_type} - #{MPEG4_AUDIO_OBJECT_TYPES[@audio_object_type] || 'Unknown'}", :dark_gray
      print prefix
      cputs "  Sampling Frequency: #{@frequency}", :dark_gray
      print prefix
      cputs "  Channel Config: #{MPEG4_CHANNEL_CONFIGURATIONS[@channel_config]}", :dark_gray
      if @extension_sampling_frequency != -1
        print prefix
        cputs "  Extension Sampling Frequency: #{@extension_sampling_frequency}", :dark_gray
      end
      print prefix
      cputs "  SBR Present: #{@sbr_present_flag}", :dark_gray
      print prefix
      cputs "  PS Present: #{@ps_present_flag}", :dark_gray
      if @core_coder_delay
        print prefix
        cputs "  Core Coder Delay: #{@core_coder_delay}", :dark_gray
      end
    end

    if @video_format
      print prefix
      cputs "Decoder Config: ", :dark_gray
      print prefix
      cputs "  Video Format: #{@video_format} - #{MPEG4_VISUAL_VIDEO_FORMATS[@video_format]}", :dark_gray
      print prefix
      cputs "  Video Range: #{@video_range} - #{MPEG4_VISUAL_VIDEO_RANGES[@video_range]}", :dark_gray
      if @color_primaries
        print prefix
        cputs "  Color primaries: #{@color_primaries} - #{MPEG4_VISUAL_COLOR_PRIMARIES[@color_primaries]}", :dark_gray
        print prefix
        cputs "  Transfer characteristics: #{@transfer_characteristics} - #{MPEG4_VISUAL_TRANSFER_CHARACTERISTICS[@transfer_characteristics]}", :dark_gray
        print prefix
        cputs "  Matrix coefficients: #{@matrix_coefficients} - #{MPEG4_VISUAL_MATRIX_COEFFICIENTS[@matrix_coefficients]}", :dark_gray
      end
    end
  end

  # Tag kinds (from http://www.protocols.com/pbook/audiov.htm ):
  # 0x00 Forbidden
  # 0x01 ObjectDescrTag
  # 0x02 InitialObjectDescrTag
  # 0x03 ES_DescrTag
  # 0x04 DecoderConfigDescrTag
  # 0x05 DecSpecificInfoTag
  # 0x06 SLConfigDescrTag
  # 0x07 ContentIdentDescrTag
  # 0x08 SupplContentIdentDescrTag
  # 0x09 IPI_DescrPointerTag
  # 0x0A IPMP_DescrPointerTag
  # 0x0B IPMP_DescrTag
  # 0x0C QoS_DescrTag
  # 0x0D RegistrationDescrTag
  # 0x0E ES_ID_IncTag
  # 0x0F ES_ID_RefTag
  # 0x10 MP4_IOD_Tag
  # 0x11 MP4_OD_Tag
  # 0x12 IPL_DescrPointerRefTag
  # 0x13 ExtendedProfileLevelDescrTag
  # 0x14 profileLevelIndicationIndexDescrTag
  # 0x15-0x3F Reserved for ISO use
  # 0x40 ContentClassificationDescrTag
  # 0x41 KeyWordDescrTag
  # 0x42 RatingDescrTag
  # 0x43 LanguageDescrTag
  # 0x44 ShortTextualDescrTag
  # 0x45 ExpandedTextualDescrTag
  # 0x46 ContentCreatorNameDescrTag
  # 0x47 ContentCreationDateDescrTag
  # 0x48 OCICreatorNameDescrTag
  # 0x49 OCICreationDateDescrTag
  # 0x4A SmpteCameraPositionDescrTag
  # 0x4B-0x5F Reserved for ISO use (OCI extensions)
  # 0x60-0xBF Reserved for ISO use
  # 0xC0-0xFE User private
  # 0xFF Forbidden

  def parse_tags(data_size = @data_size)
    while @data_stream.pos < data_size
      kind = @data_stream.ui8
      len = read_desc_length

      return if len == 0

      case kind
      when 3 # es_descr_tag -- has subitems.
        # 3 bytes are esid and stream priority
        @data_stream.read(3)
        parse_tags(len - 3)
      when 4 # decoder_config_descr_tag -- the one we want.
        @object_type = @data_stream.ui8
        stream_flags = @data_stream.ui8
        @stream_type = (stream_flags >> 2)
        @upstream_flag = (stream_flags >> 1) & 1
        @reserved_flag = stream_flags & 1
        @buffer_size = @data_stream.ui24
        @max_bitrate = @data_stream.ui32
        @bitrate = @data_stream.ui32
        if len >= 10
          parse_tags(len - 8)
        elsif len > 8
          @data_stream.read(len - 8)
        end
      when 5 # dec_specific_info_tag -- The audio specific config and such.
        @dec_specific_info = @data_stream.read(len)

        # Try decoding if it looks like an audio specific config.
        if len >= 2 && @object_type == 64
          decode_asc(@dec_specific_info)
        end

        # Try decoding if it looks like mpeg-4 visual VideoObjectSequence
        if len >= 9 && @object_type == 32
          decode_mpeg4v_video_object_sequence(@dec_specific_info)
        end

      when 6 # sl_config_descr_tag -- sync layer config descriptor...  blah.
        @data_stream.read(len)
      else # who knows
        @data_stream.read(len)
      end

    end
  end

  def read_desc_length
    length = 0
    4.times do
      b = @data_stream.ui8
      length = (length << 7) + (b & 127)
      return length if b < 128
    end
    return length
  rescue
    0
  end

  def decode_mpeg4v_video_object_sequence(data)
    vos = Bitstream.new(data)
    while vos.remaining_bits >= 32
      start_code = vos.getbits(32) & 0xff
      break unless start_code == 0xB0 # If it's not a start code, the rest won't be valid.
      profile_and_level = vos.getbits(8)

      # User data
      while vos.nextbits(32) == 0x1B2
        vos.skipbits(32) # the start code
        while vos.nextbits(24) != 1 && vos.remaining_bits > 8
          vos.skipbits(8) # Throw away this user data, since we don't need to decode it.
        end
      end

      # VisualObject
      object_code = vos.getbits(32)
      is_visual_object_id = vos.getbits(1)
      if is_visual_object_id == 1
        vos.skipbits(4) # object_version_id
        vos.skipbits(3) # object_priority
      end
      visual_object_type = vos.getbits(4)

      # 1 = video ID, 2 = still texture ID
      if visual_object_type == 1 || visual_object_type == 2
        video_signal_type = vos.getbits(1)
        if video_signal_type == 1
          @video_format = vos.getbits(3)
          @video_range = vos.getbits(1)
          color_desc = vos.getbits(1)
          if color_desc == 1
            @color_primaries = vos.getbits(8)
            @transfer_characteristics = vos.getbits(8)
            @matrix_coefficients = vos.getbits(8)
          end
        end
      end

      # None of the other visual object types matter at this point!

      # This is probably not accurate!!!  But I don't want to implement all the other data decoding,
      # so just see if we can find the next end code?
      while vos.nextbits(24) != 1 && vos.remaining_bits > 8
        vos.skipbits(8)
      end
    end

  end

  def decode_asc(data)
    asc = Bitstream.new(data)
    @audio_object_type = asc.getbits(5)
    if @audio_object_type == 31
      @audio_object_type = asc.getbits(6) + 32 # Extended object type
    end

    frequency_index = asc.getbits(4)
    if frequency_index == 15
      @frequency = asc.getbits(24) # Extended frequency
    else
      @frequency = MPEG4_AUDIO_FREQUENCIES[frequency_index]
    end
    
    @channel_config = asc.getbits(4)

    # Check for extension data.
    extension_object_type = 0
    @sbr_present_flag = 0
    @ps_present_flag = 0
    extension_sampling_frequency_index = -1
    @extension_sampling_frequency = -1
    if @audio_object_type == 5 || @audio_object_type == 29
      extension_object_type = 5
      @sbr_present_flag = 1
      @ps_present_flag = 1 if @audio_object_type == 29
      extension_sampling_frequency_index = asc.getbits(4)
      if extension_sampling_frequency_index == 0xf
        @extension_sampling_frequency = asc.getbits(24)
      else
        @extension_sampling_frequency = MPEG4_AUDIO_FREQUENCIES[extension_sampling_frequency_index]
      end

      @audio_object_type = asc.getbits(5)
      if @audio_object_type == 31
        @audio_object_type = asc.getbits(6) + 32 # Extended object type
      end
    end

    if @audio_object_type == 2 # Or a bunch of others
      # GASpecificConfig
      frame_length_flag = asc.getbits(1)
      depends_on_core_coder = asc.getbits(1)
      if depends_on_core_coder == 1
        @core_coder_delay = asc.getbits(14)
      end
      extension_flag = asc.getbits(1)
      if @channel_config == 0
        # puts "ERROR: Reading channel config from PCE is not currently supported."
        # Should read program_config_element here.
      end
      if @audio_object_type == 6 || @audio_object_type == 20
        layer_nr = asc.getbits(3)
      end
      if extension_flag == 1
        if audio_object_type == 22
          num_of_sub_frame = asc.getbits(5)
          layer_length = asc.getbits(11)
        end
        if [17,19,20.23].include?(audio_object_type)
          aac_section_data_resilience_flag = asc.getbits(1)
          aac_scalefactor_data_resilience_flag = asc.getbits(1)
          aac_spectral_data_resilience_flag = asc.getbits(1)
        end
        extension_flag_3 = asc.getbits(1)
        if extension_flag_3 == 1
          # Not yet defined!  Yay!
          # puts "ERROR: Undefined version 3 data."
        end
      end
    end

    if extension_object_type != 5 && asc.remaining_bits >= 16
      sync_extension_type = asc.getbits(11)
      if sync_extension_type == 0x2b7

        extension_object_type = asc.getbits(5)
        if extension_object_type == 31
          extension_object_type = asc.getbits(6) + 32 # Extended object type
        end

        if extension_object_type == 5
          @sbr_present_flag = asc.getbits(1)
          if @sbr_present_flag == 1
            extension_sampling_frequency_index = asc.getbits(4)
            if extension_sampling_frequency_index == 0xf
              @extension_sampling_frequency = asc.getbits(24)
            else
              @extension_sampling_frequency = mpeg4_audio_frequencies[extension_sampling_frequency_index]
            end
            if asc.remaining_bits >= 12
              sync_extension_type = asc.getbits(11)
              if sync_extension_type == 0x548
                @ps_present_flag = 1
              end
            end
          end
        end
      end
    end
  rescue
    nil
  end

end

class MetaBox < BoxWithChildren
  handles 'meta', 'Meta Data'

  def read_data(stream)
    # Handle meta entries inside itunes data differently.
    if find_parent('ilst')
      @version,@flags = stream.ui8,stream.ui24
    end

    super
  end
end

class FielSubBox < SubBox
  handles 'fiel', 'Field Order'

  attr_reader :count, :order

  def read_header_data(stream)
    @count = stream.ui8
    @order = stream.ui8
  end

  def print_extra_info(prefix = '')
    if @count.to_i > 0
      print prefix
      cputs "Count: #{@count}", :dark_gray
      print prefix
      cputs "Order: #{@order}", :dark_gray
    end
  end
end
class PaspSubBox < SubBox
  handles 'pasp', 'Pixel Aspect Ratio'

  attr_reader :h_spacing, :v_spacing

  def read_header_data(stream)
    @h_spacing = stream.ui32
    @v_spacing = stream.ui32
  end

  def print_extra_info(prefix = '')
    print prefix
    if @v_spacing.to_i > 0
      cputs "Ratio: #{@h_spacing}/#{@v_spacing} (#{sprintf('%0.3f',@h_spacing.to_f / @v_spacing)})", :dark_gray
    else
      cputs "Ratio: #{@h_spacing}/#{@v_spacing}", :dark_gray
    end
  end
end

class ClapSubBox < SubBox
  handles 'clap', 'Clean Aperture'

  attr_reader :width, :height, :h_offset, :v_offset

  def read_header_data(stream)
    @width = stream.fixed64.round
    @height = stream.fixed64.round
    @h_offset = stream.fixed64.round
    @v_offset = stream.fixed64.round
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Width: #{@width}", :dark_gray
    print prefix
    cputs "Height: #{@height}", :dark_gray
    print prefix
    cputs "Horizontal Offset: #{@h_offset}", :dark_gray
    print prefix
    cputs "Vertical Offset: #{@v_offset}", :dark_gray
  end
end

class BtrtSubBox < SubBox
  handles 'btrt', 'Bitrate'

  attr_reader :buffer_size, :max_bitrate, :avg_bitrate

  def read_header_data(stream)
    @buffer_size = stream.ui32
    @max_bitrate = stream.ui32
    @avg_bitrate = stream.ui32
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Buffer Size: #{@buffer_size} (#{(@buffer_size * 8) / 1000} kilobits)", :dark_gray
    print prefix
    cputs "Max Bitrate: #{@max_bitrate}", :dark_gray
    print prefix
    cputs "Avg Bitrate: #{@avg_bitrate}", :dark_gray
  end
end

class ChanSubBox < SubBox
  handles 'chan', 'Audio Channel Configuration'

  # From the CAF docs at http://developer.apple.com/library/mac/#documentation/MusicAudio/Reference/CAFSpec/CAF_spec/CAF_spec.html
  LAYOUTS = {
    0             => 'See Channel Descriptions',
    1<<16         => 'See Channel Bitmap',

    (100<<16) | 1 => 'Mono',
    (101<<16) | 2 => 'Stereo',
    (102<<16) | 2 => 'Stereo (Headphones)',
    (103<<16) | 2 => 'Matrix Stereo',
    (104<<16) | 2 => 'Mid-Side Stereo',
    (105<<16) | 2 => 'XY Pair Stereo',
    (106<<16) | 2 => 'Binaural Stereo',
    (107<<16) | 4 => 'Ambisonic 4',
    (108<<16) | 4 => 'Quadraphonic',
    (109<<16) | 5 => 'Pentagonal',
    (110<<16) | 6 => 'Hexagonal',
    (111<<16) | 8 => 'Octagonal',
    (112<<16) | 8 => 'Cube',

    (113<<16) | 3 => '(MPEG) L R C',
    (114<<16) | 3 => '(MPEG) C L R',
    (115<<16) | 4 => '(MPEG) L R C Cs',
    (116<<16) | 4 => '(MPEG) C L R Cs',
    (117<<16) | 5 => '(MPEG) L R C Ls Rs',
    (118<<16) | 5 => '(MPEG) L R Ls Rs C',
    (119<<16) | 5 => '(MPEG) L C R Ls Rs',
    (120<<16) | 5 => '(MPEG) C L R Ls Rs',
    (121<<16) | 6 => '(MPEG) L R C LFE Ls Rs',
    (122<<16) | 6 => '(MPEG) L R Ls Rs C LFE',
    (123<<16) | 6 => '(MPEG) L C R Ls Rs LFE',
    (124<<16) | 6 => '(MPEG) C L R Ls Rs LFE',
    (125<<16) | 7 => '(MPEG) L R C LFE Ls Rs Cs',
    (126<<16) | 8 => '(MPEG) L R C LFE Ls Rs Lc Rc',
    (127<<16) | 8 => '(MPEG) C Lc Rc L R Ls Rs LFE',
    (128<<16) | 8 => '(MPEG) L R C LFE Ls R Rls Rrs',

    (129<<16) | 8 => '(Emagic) L R Ls Rs C LFE Lc Rc',
    (130<<16) | 8 => '(SMPTE_DTV) L R C LFE Ls Rs Lt Rt (Matrix Stereo)',

    (131<<16) | 3 => '(ITU) L R Cs',
    (132<<16) | 4 => '(ITU) L R Ls Rs',

    (133<<16) | 3 => '(DVD) L R LFE',
    (134<<16) | 4 => '(DVD) L R LFE Cs',
    (135<<16) | 5 => '(DVD) L R LFE Ls Rs',
    (136<<16) | 4 => '(DVD) L R C LFE',
    (137<<16) | 5 => '(DVD) L R C LFE Cs',
    (138<<16) | 5 => '(DVD) L R Ls Rs LFE',

    (139<<16) | 6 => '(AudioUnit) L R Ls Rs C Cs',
    (140<<16) | 7 => '(AudioUnit) L R Ls Rs C Rls Rrs',

    (141<<16) | 6 => '(AAC) C L R Ls Rs Cs',
    (142<<16) | 7 => '(AAC) C L R Ls Rs Cs Lfe',
    (143<<16) | 7 => '(AAC) C L R Ls Rs Rls Rrs',
    (144<<16) | 8 => '(AAC) C L R Ls Rs Rls Rrs Cs',

    (145<<16) | 16 => '(TMH) L R C Vhc Lsd Rsd Ls Rs Vhl Vhr Lw Rw Csd Cs LFE1 LFE2',
    (146<<16) | 21 => '(TMH) L R C Vhc Lsd Rsd Ls Rs Vhl Vhr Lw Rw Csd Cs LFE1 LFE2 Lc Rc HI VI Haptic',

    (147<<16) => 'Reserved (DO NOT USE)'
  }

  attr_accessor :channel_layout, :channel_count

  def read_header_data(stream)
    tag = stream.ui32
    tag = stream.ui32 if tag == 0 # MOV and maybe MP4 add an extra zero-value here.  Not fully safe, since use_descriptions tag is zero too.
    if LAYOUTS[tag]
      @channel_layout = LAYOUTS[tag]
      @channel_count = tag & 0xff
    else
      @channel_layout = 'Unknown'
      @channel_count = 0
    end
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Channel Count: #{@channel_count}", :dark_gray
    print prefix
    cputs "Channel Layout: #{@channel_layout}", :dark_gray
  end
end

class ColrSubBox < SubBox
  handles 'colr', 'Color Parameters'

  PARAMETER_TYPES = {
    'nclc' => 'Video',
    'prof' => 'Print'
  }
  PARAMETER_TYPES.default = 'Unknown'

  COLOR_PRIMARIES = {
    1 => 'BT.709, SMPTE 274M, SMPTE 296M',
    2 => 'Unknown',
    5 => "BT.470 System B and G, BT.601 625 (Probably?)",
    6 => "BT.601 525, SMPT 170M",
  }
  COLOR_PRIMARIES.default = 'Reserved'

  TRANSFER_FUNCTIONS = {
    1 => 'BT.709, SMPTE 274M, SMPTE 296M, SMPTE 293M, SMPTE 170M',
    2 => 'Unknown',
    7 => 'SMPTE 240M, SMPTE 274M'
  }
  TRANSFER_FUNCTIONS.default = 'Reserved'

  MATRIX_COEFFICIENTS = {
    1 => 'BT.709 (1125/60/2:1 only), SMPTE 274M, SMPTE 296M',
    2 => 'Unknown',
    6 => 'BT.601, BT.470 System B and G, SMPTE 170M, SMPTE 293M',
    7 => 'SMPTE 240M, SMPTE 274M'
  }
  MATRIX_COEFFICIENTS.default = 'Reserved'

  def read_header_data(stream)
    @parameter_type = stream.fourcc
    if @parameter_type == 'nclc'
      @primaries = stream.ui16
      @transfer = stream.ui16
      @matrix = stream.ui16
    end
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Parameter type: #{@parameter_type} (#{PARAMETER_TYPES[@parameter_type]})", :dark_gray
    if @parameter_type == 'nclc'
      print prefix
      cputs "Primaries index: #{@primaries} (#{COLOR_PRIMARIES[@primaries]})", :dark_gray
      print prefix
      cputs "Transfer function index: #{@transfer} (#{TRANSFER_FUNCTIONS[@transfer]})", :dark_gray
      print prefix
      cputs "Matrix index: #{@matrix} (#{MATRIX_COEFFICIENTS[@matrix]})", :dark_gray
    end
  end
end

class AvccSubBox < SubBox
  handles 'avcC', 'AVC Configuration'

  PROFILES = {
    66 => 'Baseline',
    77 => 'Main',
    88 => 'Extended',
    100 => 'High',
    110 => 'High 10',
    122 => 'High 4:2:2',
    144 => 'High 4:4:4'
  }
  COMPAT_FLAGS = {
    128 => 'Baseline',
     64 => 'Main',
     32 => 'Extended'
  }

  CHROMA_FORMAT = ['Mono','4:2:0','4:2:2','4:4:4']

  attr_accessor :sps_units, :pps_units

  def read_header_data(stream)
    @version = stream.ui8
    @profile = stream.ui8
    @profile_compat = stream.ui8
    @level = stream.ui8
    @nal_unit_length = (stream.ui8 & 3) + 1
    @sequence_set_count = (stream.ui8 & 31)
    @sequence_set_count.times do
      len = stream.ui16
      @sps_units ||= []
      @sps_units << stream.read(len)
    end
    @picture_set_count = stream.ui8
    @picture_set_count.times do
      len = stream.ui16
      @pps_units ||= []
      @pps_units << stream.read(len)
    end
  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Version: #{@version}", :dark_gray
    print prefix
    cputs "Profile: #{@profile} (#{PROFILES[@profile] || 'Unknown'})", :dark_gray
    print prefix
    if (@profile_compat & 0b11100000) > 0
      compat_msg = ' ('
      compat_msg += COMPAT_FLAGS.keys.map { |v| (@profile_compat & v > 0) ? COMPAT_FLAGS[v] : nil }.compact.join('/')
      compat_msg += ')'
    else
      compat_msg = ''
    end
    cputs "Profile Compatibility: #{@profile_compat}#{compat_msg}", :dark_gray
    print prefix
    cputs "Level: #{sprintf('%0.1f', @level / 10.0)}", :dark_gray
    print prefix
    cputs "NAL Unit Length: #{@nal_unit_length}", :dark_gray
    print prefix
    cputs "Sequence Set Count: #{@sequence_set_count}", :dark_gray
    print_sps_units(prefix+'  ')# if $VERBOSE
    print prefix
    cputs "Picture Set Count: #{@picture_set_count}", :dark_gray
    if $VERBOSE
      @pps_units.each do |pps_unit|
        print prefix+'  '
        cputs "Picture Parameter Set: #{pps_unit.hex}", :dark_gray
      end
      print_pps_units(prefix+'  ')
    end
  end

  def print_pps_units(prefix = '')
    @pps_units.each do |unit_data|
    end
  end

  def print_sps_units(prefix = '')
    # SPS
    # 67 42 C0 1E DB 02 80 BF E5 C0 44 00 00 03 01 F4 00 00 5D AA 3C 58 BB 80
    #
    # 67 = 0,11,00111 = zero bit, ref_idc, unit_type (7=seq_parameter_set_rbsp)
    # 42 = profile IDC
    # C0 = constraint flags plus reserved
    # 1E = level
    #
    # 1101 1011 0000 0010 1000 0000 1011 1111 1110 0101 1100 1000 1000
    #
    #
    #

    # -----------------------------

    # 27 64 00 28 AD 00 D3 03 00 EF E2 30 11 00 00 0F A4 00 03 A9 80 E8 60 00 F4 24 00 01 12 A8 AE F2 E3 43 00 07 A1 20 00 08 95 45 77 97 0E E1 10 8A 2C
    #
    # 27 = 0,01,00111,
    #
    # 0110 0100 = profile (100)
    # 0000 0000 = constraint flags
    # 0010 1000 = level (40)
    # 1 = sps_id = 0
    # 010 = chroma_format_idc (1)
    # 11 = bit depth (luma = 0, chroma = 0)
    # 0 = qpprime flag
    # 1 = seq_scaling_matrix_present flag (8 entries)
    #   0000 0000 = none present
    # 1 = log2_max_frame_num_minus4 (0)
    # 1 = pic_order_cnt_type (0)
    # 010 = log2_max_pic_order_cnt_lsb_minus4 (1)
    # 011 = max_ref_frames (2)
    # 0 = gaps_allowed flag
    # 00000110000 = mb_width_minus_1 = 47
    # 000011101 = mb_height_minus_1 = 28
    # 111 1110 0010 0011 0000 0001 0001 0000 0000 0000 0000 0000 1111
    #
    #

    # PPS
    # 68 CA 81 3C 80
    #

    @sps_units.each do |unit_data|
      header_byte = unit_data[0,1].unpack('C').first
      if header_byte >= 128
        print prefix
        cputs "Invalid nal unit!", :red
        next
      end

      ref_idc = header_byte >> 5
      unit_type = header_byte & 0b11111

      clean_data = []

      nal_size = unit_data.length
      i = 1
      while i < nal_size
        if i + 2 < nal_size && unit_data[i,3] == "\x00\x00\x03"
          clean_data << unit_data[i,1].unpack('C').first
          clean_data << unit_data[i,1].unpack('C').first
          i += 2
        else
          clean_data << unit_data[i,1].unpack('C').first
        end
        i += 1
      end

      unit = Bitstream.new(clean_data, 0)

      profile = unit.getbits(8)
      constraint_flags = unit.getbits(8)
      level = unit.getbits(8)
      sps_id = unit.ue_v

      print prefix
      cputs "NAL unit type: #{unit_type}", :dark_gray
      print prefix+'  '
      cputs "Profile: #{profile} (#{PROFILES[profile] || 'Unknown'})", :dark_gray
      print prefix+'  '
      cputs "Level: #{sprintf('%0.1f', level / 10.0)}", :dark_gray
      print prefix+'  '
      cputs "SPS ID: #{sps_id}", :dark_gray

      if [100,110,122,244,44,83,86,118,128].include?(profile)
        chroma_format_idc = unit.ue_v
        if chroma_format_idc == 3
          separate_color_plane_flag = unit.getbits(1)
        else
          separate_color_plane_flag = 0
        end

        bit_depth_luma_minus8 = unit.ue_v
        bit_depth_chroma_minus8 = unit.ue_v

        qpprime_y_zero_transform_bypass_flag = unit.getbits(1)
        seq_scaling_matrix_present_flag = unit.getbits(1)

        if seq_scaling_matrix_present_flag == 1
          entry_count = (chroma_format_idc != 3) ? 8 : 12
          entry_count.times do |i|
            if unit.getbits(1) == 1
              read_scaling_list(unit, (i < 6) ? 16 : 64)
            end
          end
        end

      else
        chroma_format_idc = 1
        separate_color_plane_flag = 0
        bit_depth_luma_minus8 = 0
        bit_depth_chroma_minus8 = 0
      end

      if separate_color_plane_flag == 1
        chroma_array_type = 0
      else
        chroma_array_type = chroma_format_idc
      end

      case chroma_format_idc
      when 1
        sub_width_c, sub_height_c = 2, 2
      when 2
        sub_width_c, sub_height_c = 2, 1
      else
        sub_width_c, sub_height_c = 1, 1
      end

      mb_width_c = 16 / sub_width_c
      mb_height_c = 16 / sub_height_c

      max_frame_num = 2 ** (unit.ue_v + 4)
      pic_order_count_type = unit.ue_v

      if pic_order_count_type == 0
        log2_max_pic_order_cnt_lsb_minus4 = unit.ue_v
      elsif pic_order_count_type == 1
        delta_pic_order_always_zero_flag = unit.getbits(1)
        offset_for_non_ref_pic = unit.se_v
        offset_for_top_to_bottom_field = unit.se_v
        num_ref_frames_in_pic_order_cnt_cycle = unit.ue_v

        offset_for_ref_frame = []
        num_ref_frames_in_pic_order_cnt_cycle.times do
          offset_for_ref_frame << unit.se_v
        end
      end

      max_num_ref_frames = unit.ue_v
      gaps_in_frame_num_value_allowed_flag = unit.getbits(1)

      pic_width_in_mbs_minus1 = unit.ue_v
      pic_height_in_map_units_minus1 = unit.ue_v
      frame_mbs_only_flag = unit.getbits(1)

      if frame_mbs_only_flag == 0
        mb_adaptive_frame_field_flag = unit.getbits(1)
      else
        mb_adaptive_frame_field_flag = 0
      end

      frame_height_in_mbs = (2-frame_mbs_only_flag) * (pic_height_in_map_units_minus1 + 1)

      print prefix+'  '
      cputs "Max Frame Num: #{max_frame_num}", :dark_gray
      print prefix+'  '
      cputs "Max Ref Frames: #{max_num_ref_frames}", :dark_gray

      print prefix+'  '
      cputs "Chroma Format: #{chroma_format_idc} (" + (CHROMA_FORMAT[chroma_format_idc] || 'Unknown') + ")", :dark_gray
      print prefix+'  '
      cputs "Bit Depth: #{bit_depth_luma_minus8 + 8} (luma), #{bit_depth_chroma_minus8 + 8} (chroma)", :dark_gray
      print prefix+'  '
      cputs "Macroblock Width: #{pic_width_in_mbs_minus1 + 1} (#{(pic_width_in_mbs_minus1 + 1) * 16} pixels luma, #{(pic_width_in_mbs_minus1 + 1) * mb_width_c} pixels chroma)", :dark_gray
      print prefix+'  '
      cputs "Map Unit Height: #{pic_height_in_map_units_minus1 + 1} (#{frame_height_in_mbs * 16} pixels luma, #{frame_height_in_mbs * mb_height_c} pixels chroma)", :dark_gray


      direct_8x8_inference_flag = unit.getbits(1)

      frame_cropping_flag = unit.getbits(1)
      if frame_cropping_flag == 1
        crop_offsets = []
        4.times { crop_offsets << unit.ue_v }
        print prefix+'  '
        cputs "Frame cropping offsets: " + crop_offsets.join(', ') + ' (L,R,T,B)', :dark_gray

        if chroma_array_type == 0
          crop_unit_x = 1
          crop_unit_y = 2 - frame_mbs_only_flag
        else
          crop_unit_x = sub_width_c
          crop_unit_y = sub_height_c * (2 - frame_mbs_only_flag)
        end

        croprect = []
        croprect << (crop_unit_x * crop_offsets[0])
        croprect << (crop_unit_y * crop_offsets[2])
        croprect << ((pic_width_in_mbs_minus1 + 1) * 16 - (crop_unit_x * crop_offsets[1] + 1))
        croprect << (frame_height_in_mbs * 16 - (crop_unit_y * crop_offsets[3] + 1))

        croprect << (croprect[2] - croprect[0] + 1)
        croprect << (croprect[3] - croprect[1] + 1)

        print prefix+'  '
        cputs "Frame crop rectangle: (#{croprect[0]},#{croprect[1]})-(#{croprect[2]},#{croprect[3]}) = (#{croprect[4]},#{croprect[5]})", :dark_gray
      end

      vui_parameters_present_flag = unit.getbits(1)

      print prefix+'  '
      cputs "VUI parameters present: #{vui_parameters_present_flag}", :dark_gray
      if vui_parameters_present_flag == 1

        aspect_ratio_info_present_flag = unit.getbits(1)
        if aspect_ratio_info_present_flag == 1
          aspect_ratio_idc = unit.getbits(8)
          if aspect_ratio_idc == 255
            sar_width = unit.getbits(16)
            sar_height = unit.getbits(16)
            print prefix+'  '
            cputs "Sample Aspect Ratio: #{sar_width}:#{sar_height}", :dark_gray
          else
            print prefix+'  '
            aspect_descriptions = ['Unspecified','1:1','12:11','10:11','16:11','40:33','24:11','20:11','32:11','80:33','18:11','15:11','64:33','160:99','4:3','3:2','2:1']
            cputs "Sample Aspect Ratio: #{aspect_descriptions[aspect_ratio_idc] || 'Unknown'}", :dark_gray
          end
        end

        overscan_info_present_flag = unit.getbits(1)
        if overscan_info_present_flag == 1
          overscan_appropriate_flag = unit.getbits(1)
          print prefix+'  '
          cputs "Overscan Appropriate: #{overscan_appropriate_flag}", :dark_gray
        end

        video_signal_type_present_flag = unit.getbits(1)
        if video_signal_type_present_flag == 1
          video_format = unit.getbits(3)
          video_full_range_flag = unit.getbits(1)
          print prefix+'  '
          video_format_descriptions = ['Component','PAL','NTSC','SECAM','MAC','Unspecified video format','Reserved','Reserved']
          cputs "Video Format: #{video_format_descriptions[video_format] || 'Unknown'}", :dark_gray
          print prefix+'  '
          cputs "Video Full Range Flag: #{video_full_range_flag}", :dark_gray

          color_description_preset_flag = unit.getbits(1)
          if color_description_preset_flag == 1
            color_primaries = unit.getbits(8)
            transfer_characteristics = unit.getbits(8)
            matrix_coefficients = unit.getbits(8)

            print prefix+'  '
            cputs "Color Description: primaries=#{color_primaries}, transfer=#{transfer_characteristics}, matrix=#{matrix_coefficients}", :dark_gray
          end
        end

        chroma_loc_info_present_flag = unit.getbits(1)
        if chroma_loc_info_present_flag == 1
          chroma_sample_loc_type_top_field = unit.ue_v
          chroma_sample_loc_type_bottom_field = unit.ue_v
          print prefix+'  '
          cputs "Chroma Sample Loc Type: top_field=#{chroma_sample_loc_type_top_field}, bottom_field=#{chroma_sample_loc_type_bottom_field}", :dark_gray
        end

        timing_info_present_flag = unit.getbits(1)
        if timing_info_present_flag == 1
          num_units_in_tick = unit.getbits(32)
          time_scale = unit.getbits(32)
          fixed_frame_rate_flag = unit.getbits(1)
          print prefix+'  '
          cputs "Timing Info: num_units_in_tick=#{num_units_in_tick}, time_scale=#{time_scale}, fixed_frame_rate_flag=#{fixed_frame_rate_flag}", :dark_gray
        end

        # After this comes nal_hrd params and vcl_hrd_params and all sorts of nonsense.
        nal_hrd_present_flag = unit.getbits(1)
        if nal_hrd_present_flag == 1
          print prefix+'  '
          cputs "NAL/HRD present! (Not decoding...)", :dark_gray
          return
        end

        vcl_hrd_present_flag = unit.getbits(1)
        if vcl_hrd_present_flag == 1
          print prefix+'  '
          cputs "VCL/HRD present! (Not decoding...)", :dark_gray
          return
        end

        if nal_hrd_present_flag == 1 || vcl_hrd_present_flag == 1
          low_delay_hrd_flag = unit.getbits(1)
        end

        pic_struct_present_flag = unit.getbits(1)

        bitstream_restriction_flag = unit.getbits(1)
        if bitstream_restriction_flag == 1
          motion_vectors_over_pic_boundaries_flag = unit.getbits(1)
          max_bytes_per_pic_denom = unit.ue_v
          max_bits_per_mb_denom = unit.ue_v
          log2_max_mv_length_horizontal = unit.ue_v
          log2_max_mv_length_vertical = unit.ue_v
          num_reorder_frames = unit.ue_v
          max_dec_frame_buffering = unit.ue_v

          if $VERBOSE2
            print prefix+'  '
            cputs "Bitstream restriction settings:", :dark_gray

            print prefix+'    '
            cputs "motion_vectors_over_pic_boundaries_flag = #{motion_vectors_over_pic_boundaries_flag}", :dark_gray
            print prefix+'    '
            cputs "max_bytes_per_pic_denom                 = #{max_bytes_per_pic_denom}", :dark_gray
            print prefix+'    '
            cputs "max_bits_per_mb_denom                   = #{max_bits_per_mb_denom}", :dark_gray
            print prefix+'    '
            cputs "log2_max_mv_length_horizontal           = #{log2_max_mv_length_horizontal}", :dark_gray
            print prefix+'    '
            cputs "log2_max_mv_length_vertical             = #{log2_max_mv_length_vertical}", :dark_gray
            print prefix+'    '
            cputs "num_reorder_frames                      = #{num_reorder_frames}", :dark_gray
            print prefix+'    '
            cputs "max_dec_frame_buffering                 = #{max_dec_frame_buffering}", :dark_gray
          end
        end

      end # vui parameters
    end

  end

  def read_scaling_list(unit, size)
    # Read and dump the scaling list...
    scaling_list = []
    last_scale = 8
    next_scale = 8

    size.times do |j|
      if next_scale != 0
        delta_scale = unit.se_v
        next_scale = (last_scale + delta_scale + 256) % 256
      end
      scaling_list[j] = (next_scale == 0) ? last_scale : next_scale
      last_scale = scaling_list[j]
    end

  end

end

class HvccSubBox < SubBox
  handles 'hvcC', 'HVC Configuration'

  # see http://tools.ietf.org/html/draft-ietf-payload-rtp-h265-02 (page 45)

  PROFILES = {
      1 => 'Main',
      2 => 'Main_10',
      3 => 'Main_Still_Picture'
  }

  TIERS = {
      0 => 'Main',
      1 => 'High'
  }

  CHROMA_FORMAT = ['Mono','4:2:0','4:2:2','4:4:4']

  PARALLELISM_TYPE = [
      'Mixed types or Unknown',
      'Slice based',
      'Tile based',
      'Entropy coding synchronization based / WPP: Wavefront Parallel Processing'
  ]

  NALU_TYPE = [
      'NAL_SLICE_TRAIL_N',
      'NAL_SLICE_TRAIL_R',
      'NAL_SLICE_TSA_N',
      'NAL_SLICE_TSA_R',
      'NAL_SLICE_STSA_N',
      'NAL_SLICE_STSA_R',
      'NAL_SLICE_RADL_N',
      'NAL_SLICE_RADL_R',
      'NAL_SLICE_RASL_N',
      'NAL_SLICE_RASL_R',
      '', '', '', '', '', '',
      'NAL_SLICE_BLA_W_LP',
      'NAL_SLICE_BLA_W_RADL',
      'NAL_SLICE_BLA_N_LP',
      'NAL_SLICE_IDR_W_RADL',
      'NAL_SLICE_IDR_N_LP',
      'NAL_SLICE_CRA_NUT',
      '', '', '', '', '',
      '', '', '', '', '',
      'NAL_VPS',
      'NAL_SPS',
      'NAL_PPS',
      'NAL_AUD',
      'NAL_EOS',
      'NAL_EOB',
      'NAL_FD',
      'NAL_PREFIX_SEI',
      'NAL_SUFFIX_SEI'
  ]

  attr_accessor :sps_units, :pps_units, :vps_units

  def read_header_data(stream)
    @version = stream.ui8
    # TODO version 0 vs 1
    next_byte = stream.ui8
    @general_profile_space = (next_byte >> 6) & 0x03
    @general_tier_flag = (next_byte >> 5) & 0x01
    @general_profile_idc = next_byte & 0x1f
    @profile_compatibility_flags = stream.ui32
    @constraint_indicator_flags = []
    6.times do |n|
      @constraint_indicator_flags << stream.ui8
    end
    @progressive_source    = (@constraint_indicator_flags[0] & 0b10000000) >> 7
    @interlaced_source     = (@constraint_indicator_flags[0] & 0b01000000) >> 6
    @non_packed_constraint = (@constraint_indicator_flags[0] & 0b00100000) >> 5
    @frame_only_constraint = (@constraint_indicator_flags[0] & 0b00010000) >> 4
    @level_idc = stream.ui8
    @min_spatial_segmentation_idc = stream.ui16 & 0x0fff
    @parallelism_type = (stream.ui8 >> 2 ) & 0x03
    @chroma_format_idc = stream.ui8 & 0x03
    @bit_depth_luma_minus8 = stream.ui8 & 0x07
    @bit_depth_chroma_minus8 = stream.ui8 & 0x07

    @average_fps = stream.ui16
    next_byte = stream.ui8
    @constant_fps = (next_byte >> 6) & 0x03
    @number_temporal_layers = (next_byte >> 3) & 0x07
    @temporal_id_nested = (next_byte >> 2) & 0x01
    @length_size_minus_one = next_byte & 0x03

    number_of_arrays = stream.ui8
    @vps_units = []
    @sps_units = []
    @pps_units = []
    number_of_arrays.times do |i|
      next_byte = stream.ui8
      # ever false here?
      array_completeness = (next_byte >> 7) & 0x01
      nal_unit_type = next_byte & 0x3F
      num_nalus = stream.ui16
      num_nalus.times do |j|
        nal_unit_length = stream.ui16
        nalu = stream.read(nal_unit_length)
        case nal_unit_type
        when 32
          @vps_units << nalu
        when 33
          @sps_units << nalu
        when 34
          @pps_units << nalu
        end
      end
    end

    # TODO parse nalus
    #   see http://ffmpeg.org/doxygen/trunk/hevc__ps_8c_source.html

  end

  def print_extra_info(prefix = '')
    print prefix
    cputs "Version: #{@version}", :dark_gray
    print prefix
    cputs "Profile: #{@general_profile_idc} (#{PROFILES[@general_profile_idc] || 'Unknown'}), Profile Space: #{@general_profile_space}", :dark_gray
    print prefix
    cputs "Tier: #{TIERS[@general_tier_flag] || 'Unknown'}", :dark_gray
    print prefix
    cputs "Level: #{sprintf('%0.1f', @level_idc / 30.0)}", :dark_gray
    print prefix
    cputs "Profile Compatibility: [#{@profile_compatibility_flags.to_s(2).rjust(32, '0')}]", :dark_gray
    #constraint_flag_view = []
    #6.times do |n|
    #  constraint_flag_view << @constraint_indicator_flags[n].to_s(2).rjust(8, '0')
    #end
    #print prefix
    #cputs "Constraint Indicator Flags: [#{constraint_flag_view.join('],[')}]", :dark_gray
    print prefix
    cputs "Progressive Source: #{!@progressive_source.zero?}", :dark_gray
    print prefix
    cputs "Interlaced Source: #{!@interlaced_source.zero?}", :dark_gray
    print prefix
    cputs "Non-Packed: #{!@non_packed_constraint.zero?}", :dark_gray
    print prefix
    cputs "Frame-Only: #{!@frame_only_constraint.zero?}", :dark_gray
    print prefix
    cputs "Min Spatial Segmentation IDC: #{@min_spatial_segmentation_idc}", :dark_gray
    print prefix
    cputs "Parallelism Type: #{PARALLELISM_TYPE[@parallelism_type]}", :dark_gray


    print prefix
    cputs "Chroma Format: #{@chroma_format_idc} (" + (CHROMA_FORMAT[@chroma_format_idc] || 'Unknown') + ")", :dark_gray
    print prefix
    cputs "Bit Depth: #{@bit_depth_luma_minus8 + 8} (luma), #{@bit_depth_chroma_minus8 + 8} (chroma)", :dark_gray

    print prefix
    cputs "Average FPS: #{@average_fps}", :dark_gray
    print prefix
    cputs "Constant FPS: #{@constant_fps}", :dark_gray
    print prefix
    cputs "Num Temporal Layers: #{@number_temporal_layers}", :dark_gray
    print prefix
    cputs "Temporal Id Nested: #{@temporal_id_nested}", :dark_gray
    print prefix
    cputs "Length Size: #{@length_size_minus_one+1}", :dark_gray
  end

end

#################################################################################

# rainbow

$VERBOSE = false
$VERBOSE2 = false
$DEBUG = false

while ['-v','-vv','-nc'].include?(ARGV.first)
  arg = ARGV.shift
  case arg
  when '-v'
    $VERBOSE = true
  when '-vv'
    $VERBOSE = true
    $VERBOSE2 = true
  end
end

error "Please specify a file to inspect." unless ARGV.length > 0

input_filename = ARGV.first
error "Input file not found." unless File.exist?(input_filename)

file_size = File.size(input_filename)
input_file = File.open(input_filename)

begin
  file = BoxFile.new(input_file)
  file.parse
ensure
  file.print_tree
end
